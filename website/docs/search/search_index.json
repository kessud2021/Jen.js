{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Jen.js \u2014 a modern TypeScript-first framework for building static-generated (SSG) and server-rendered (SSR) web applications with Preact. Key Features TypeScript-first : Full TypeScript support with strict type checking Dual rendering modes : Static Site Generation (SSG) and Server-Side Rendering (SSR) Preact-powered : Use the lightweight 3KB alternative to React Zero-config routing : Automatic file-based routing based on your file structure Native module stubs : Ready for high-performance native compilation (Rust/C++) Plugin system : Extensible architecture via TypeScript plugins Multi-database support : SQLite, PostgreSQL, MySQL, MongoDB, and jDB Built-in middleware : Express-style middleware system for request handling Production-ready : Optimized build pipeline with automatic optimization Quick Commands # Install dependencies npm install # Development server (SSR) npm run dev # Build static site (SSG) npm run build # Type checking npm run typecheck # Start production server npm run start # Clean build artifacts npm run clean Documentation Structure Getting Started \u2014 Introduction, installation, and quick start Core Concepts \u2014 Routing, configuration, and project structure Features \u2014 SSG/SSR, databases, auth, caching, and more Advanced Topics \u2014 Build system, native modules, performance API Reference \u2014 Complete API documentation Guides \u2014 Practical examples and tutorials FAQ \u2014 Common questions and answers Architecture Overview Request/Build | File-based Routing (site/) | Config & Middleware | Component Rendering (Preact SSR) | Static Output (dist/) OR Dynamic Response What's Included Build System : esbuild-powered asset bundling and optimization Server : High-performance Node.js server with middleware support Runtime : Preact SSR rendering with client-side hydration Database : Multi-driver abstraction layer Authentication : JWT-based auth utilities Caching : Built-in caching layer with Redis support Plugins : Plugin system for extending framework capabilities Use Cases Static websites \u2014 Blogs, documentation, marketing sites Server-rendered apps \u2014 Dynamic content with SEO Hybrid applications \u2014 Mix SSG and SSR on the same site Real-time applications \u2014 WebSocket support with middleware REST APIs \u2014 API-first architecture with automatic routes Next Steps Install Jen.js and set up your first project Learn the basics with routing and configuration Create your first page with Preact Explore features like databases and authentication Deploy to production with best practices","title":"Home"},{"location":"#key-features","text":"TypeScript-first : Full TypeScript support with strict type checking Dual rendering modes : Static Site Generation (SSG) and Server-Side Rendering (SSR) Preact-powered : Use the lightweight 3KB alternative to React Zero-config routing : Automatic file-based routing based on your file structure Native module stubs : Ready for high-performance native compilation (Rust/C++) Plugin system : Extensible architecture via TypeScript plugins Multi-database support : SQLite, PostgreSQL, MySQL, MongoDB, and jDB Built-in middleware : Express-style middleware system for request handling Production-ready : Optimized build pipeline with automatic optimization","title":"Key Features"},{"location":"#quick-commands","text":"# Install dependencies npm install # Development server (SSR) npm run dev # Build static site (SSG) npm run build # Type checking npm run typecheck # Start production server npm run start # Clean build artifacts npm run clean","title":"Quick Commands"},{"location":"#documentation-structure","text":"Getting Started \u2014 Introduction, installation, and quick start Core Concepts \u2014 Routing, configuration, and project structure Features \u2014 SSG/SSR, databases, auth, caching, and more Advanced Topics \u2014 Build system, native modules, performance API Reference \u2014 Complete API documentation Guides \u2014 Practical examples and tutorials FAQ \u2014 Common questions and answers","title":"Documentation Structure"},{"location":"#architecture-overview","text":"Request/Build | File-based Routing (site/) | Config & Middleware | Component Rendering (Preact SSR) | Static Output (dist/) OR Dynamic Response","title":"Architecture Overview"},{"location":"#whats-included","text":"Build System : esbuild-powered asset bundling and optimization Server : High-performance Node.js server with middleware support Runtime : Preact SSR rendering with client-side hydration Database : Multi-driver abstraction layer Authentication : JWT-based auth utilities Caching : Built-in caching layer with Redis support Plugins : Plugin system for extending framework capabilities","title":"What's Included"},{"location":"#use-cases","text":"Static websites \u2014 Blogs, documentation, marketing sites Server-rendered apps \u2014 Dynamic content with SEO Hybrid applications \u2014 Mix SSG and SSR on the same site Real-time applications \u2014 WebSocket support with middleware REST APIs \u2014 API-first architecture with automatic routes","title":"Use Cases"},{"location":"#next-steps","text":"Install Jen.js and set up your first project Learn the basics with routing and configuration Create your first page with Preact Explore features like databases and authentication Deploy to production with best practices","title":"Next Steps"},{"location":"faq/","text":"General Questions What is Jen.js? Jen.js is a TypeScript-first framework for building static-generated (SSG) and server-rendered (SSR) web applications with Preact. It combines the simplicity of file-based routing with the power of TypeScript and multiple database drivers. How does Jen.js compare to Next.js? Feature Jen.js Next.js Language TypeScript first JavaScript + TypeScript Framework Preact React Bundle size Smaller (3KB Preact) Larger (40KB React) Database Built-in abstraction Via third-party libraries Authentication JWT included Via third-party libraries Configuration Convention over config More configuration Learning curve Easier Steeper Choose Jen.js if you want lightweight, TypeScript-first development. Choose Next.js if you need the React ecosystem. Is Jen.js production-ready? Jen.js framework is production-ready. However, as with any framework, thoroughly test your application before deploying. The core features (routing, SSG, SSR, database) are stable. Can I use React instead of Preact? Jen.js is built around Preact. You can use React components, but they'll be larger. Preact is 70% API-compatible with React, so most code works with minimal changes. How do I contribute? Jen.js is open source. See the README for contribution guidelines. All contributions welcome. Getting Started How do I install Jen.js? npm create jen-app@latest my-app cd my-app npm install npm run dev Where do I put my pages? Create files in the site/ directory with the naming pattern (name).tsx : site/(home).tsx \u2192 / site/(about).tsx \u2192 /about site/blog/($slug).tsx \u2192 /blog/:slug How do I create an API endpoint? Create .ts files instead of .tsx : // site/api/(users).ts export async function handle ( req , res ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [] })); } Routing How do I handle dynamic routes? Use $ prefix for parameters: // site/posts/($id).tsx export async function loader ( ctx ) { return { post : await getPost ( ctx . params . id ) }; } How do I create nested routes? Just create subdirectories: site/ \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 (index).tsx \u2192 /blog \u2502 \u2514\u2500\u2500 ($slug).tsx \u2192 /blog/:slug \u2514\u2500\u2500 docs/ \u2514\u2500\u2500 (intro).tsx \u2192 /docs/intro How do I handle 404s? Create site/(404).tsx or use catch-all routes: // site/(...rest).tsx - Catches all unmatched routes export default function NotFound () { return < h1 > 404 Not Found < /h1>; } Development How do I access environment variables? Use process.env : const apiKey = process . env . API_KEY ; const isDev = process . env . NODE_ENV === 'development' ; How do I use TypeScript? Jen.js is TypeScript-first. Just use .tsx and .ts files: interface User { id : string ; name : string ; } export async function loader ( ctx : LoaderContext ) : Promise < User > { return { id : '1' , name : 'Alice' }; } How do I debug? Use console.log, debugger, or a debugger tool: // VS Code debugger export async function loader ( ctx ) { debugger ; // Pause here return { /* ... */ }; } How do I structure large projects? Organize by feature: src/ \u251c\u2500\u2500 features/ \u2502 \u251c\u2500\u2500 auth/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 types.ts \u2502 \u251c\u2500\u2500 users/ \u2502 \u2514\u2500\u2500 posts/ Building & Deployment What's the difference between npm run build and npm run dev? npm run dev starts a development server with SSR npm run build generates static HTML files for SSG How do I deploy? Static sites (SSG): npm run build # Deploy dist/ to any CDN (Netlify, Vercel, etc.) Server-rendered (SSR): npm run build npm run start # Deploy to Node.js hosting (Heroku, Railway, etc.) Can I deploy to Vercel/Netlify? Yes! Use SSG mode to generate static files, then deploy dist/ to either service. For SSR with dynamic routes, deploy to a Node.js compatible platform. How do I optimize for production? Use SSG when possible Enable minification in jen.config.ts Remove source maps in production Cache static assets on CDN Use HTTP caching headers Monitor bundle size Databases How do I connect to a database? const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } } } }; Which database should I use? SQLite \u2014 Development, small projects PostgreSQL \u2014 Production, complex queries MySQL \u2014 Production, shared hosting MongoDB \u2014 Flexible schema, document storage jDB \u2014 Lightweight, embedded How do I run migrations? Create migration files and run: npm run migrate How do I handle database errors? export async function loader ( ctx ) { try { const user = await getUser ( ctx . params . id ); return { user }; } catch ( err ) { ctx . response . writeHead ( 500 ); ctx . response . end ( 'Server error' ); return {}; } } Features How do I add authentication? import { signToken , verifyToken } from '@src/auth/jwt' ; const token = signToken ({ userId : '1' }, '7d' ); const payload = verifyToken ( token ); How do I use middleware? Create middleware in src/middleware/ : export async function authMiddleware ( req , res , next ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( 'Unauthorized' ); return ; } next (); } How do I add caching? Configure in jen.config.ts : const config : FrameworkConfig = { cache : { type : 'redis' , config : { url : 'redis://localhost:6379' } } }; Or use HTTP caching headers: export async function loader ( ctx ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); return { /* ... */ }; } How do I create a plugin? Create in src/plugins/ : export default { name : 'my-plugin' , onBuild : async () => { console . log ( 'Building...' ); }, onServe : async () => { console . log ( 'Serving...' ); } }; Performance How can I improve build speed? Use SSG for static content Avoid heavy computations in loaders Cache API responses Use database indexes How can I improve runtime performance? Minimize JavaScript Use SSR for dynamic content Cache responses Optimize database queries Use CDN for static assets How do I monitor performance? export async function loader ( ctx ) { const start = Date . now (); const data = await fetchData (); console . log ( `Took ${ Date . now () - start } ms` ); return { data }; } Troubleshooting Routes not working? Check file naming: (name).tsx not name.tsx Ensure files are in site/ directory Restart dev server TypeScript errors? Run npm run typecheck Check for missing type definitions Verify tsconfig.json configuration Build fails? Check for syntax errors Run npm run typecheck first Check plugin configurations See build output for error details Dev server slow? Check for slow loaders Reduce database queries Use caching Monitor network requests Database connection fails? Verify DATABASE_URL in .env Check database is running Check credentials Verify firewall/network access Advanced How do I add TypeScript types? Create .d.ts files or use src/types/ : // src/types/global.d.ts declare global { interface Window { myVar : string ; } } export {}; How do I use WebSockets? Currently not directly supported. Use polling or upgrade to a more complex server setup. How do I add GraphQL? Use with API routes: import { graphql } from 'graphql' ; import { schema } from '@src/lib/graphql' ; export async function handle ( req , res ) { const result = await graphql ({ schema , source : req.body }); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( result )); } How do I extend the framework? Create plugins Create custom middleware Create shared components and utilities Use path aliases for imports Still Have Questions? Check the full documentation Open an issue on GitHub Ask in discussions","title":"FAQ"},{"location":"faq/#general-questions","text":"","title":"General Questions"},{"location":"faq/#what-is-jenjs","text":"Jen.js is a TypeScript-first framework for building static-generated (SSG) and server-rendered (SSR) web applications with Preact. It combines the simplicity of file-based routing with the power of TypeScript and multiple database drivers.","title":"What is Jen.js?"},{"location":"faq/#how-does-jenjs-compare-to-nextjs","text":"Feature Jen.js Next.js Language TypeScript first JavaScript + TypeScript Framework Preact React Bundle size Smaller (3KB Preact) Larger (40KB React) Database Built-in abstraction Via third-party libraries Authentication JWT included Via third-party libraries Configuration Convention over config More configuration Learning curve Easier Steeper Choose Jen.js if you want lightweight, TypeScript-first development. Choose Next.js if you need the React ecosystem.","title":"How does Jen.js compare to Next.js?"},{"location":"faq/#is-jenjs-production-ready","text":"Jen.js framework is production-ready. However, as with any framework, thoroughly test your application before deploying. The core features (routing, SSG, SSR, database) are stable.","title":"Is Jen.js production-ready?"},{"location":"faq/#can-i-use-react-instead-of-preact","text":"Jen.js is built around Preact. You can use React components, but they'll be larger. Preact is 70% API-compatible with React, so most code works with minimal changes.","title":"Can I use React instead of Preact?"},{"location":"faq/#how-do-i-contribute","text":"Jen.js is open source. See the README for contribution guidelines. All contributions welcome.","title":"How do I contribute?"},{"location":"faq/#getting-started","text":"","title":"Getting Started"},{"location":"faq/#how-do-i-install-jenjs","text":"npm create jen-app@latest my-app cd my-app npm install npm run dev","title":"How do I install Jen.js?"},{"location":"faq/#where-do-i-put-my-pages","text":"Create files in the site/ directory with the naming pattern (name).tsx : site/(home).tsx \u2192 / site/(about).tsx \u2192 /about site/blog/($slug).tsx \u2192 /blog/:slug","title":"Where do I put my pages?"},{"location":"faq/#how-do-i-create-an-api-endpoint","text":"Create .ts files instead of .tsx : // site/api/(users).ts export async function handle ( req , res ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [] })); }","title":"How do I create an API endpoint?"},{"location":"faq/#routing","text":"","title":"Routing"},{"location":"faq/#how-do-i-handle-dynamic-routes","text":"Use $ prefix for parameters: // site/posts/($id).tsx export async function loader ( ctx ) { return { post : await getPost ( ctx . params . id ) }; }","title":"How do I handle dynamic routes?"},{"location":"faq/#how-do-i-create-nested-routes","text":"Just create subdirectories: site/ \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 (index).tsx \u2192 /blog \u2502 \u2514\u2500\u2500 ($slug).tsx \u2192 /blog/:slug \u2514\u2500\u2500 docs/ \u2514\u2500\u2500 (intro).tsx \u2192 /docs/intro","title":"How do I create nested routes?"},{"location":"faq/#how-do-i-handle-404s","text":"Create site/(404).tsx or use catch-all routes: // site/(...rest).tsx - Catches all unmatched routes export default function NotFound () { return < h1 > 404 Not Found < /h1>; }","title":"How do I handle 404s?"},{"location":"faq/#development","text":"","title":"Development"},{"location":"faq/#how-do-i-access-environment-variables","text":"Use process.env : const apiKey = process . env . API_KEY ; const isDev = process . env . NODE_ENV === 'development' ;","title":"How do I access environment variables?"},{"location":"faq/#how-do-i-use-typescript","text":"Jen.js is TypeScript-first. Just use .tsx and .ts files: interface User { id : string ; name : string ; } export async function loader ( ctx : LoaderContext ) : Promise < User > { return { id : '1' , name : 'Alice' }; }","title":"How do I use TypeScript?"},{"location":"faq/#how-do-i-debug","text":"Use console.log, debugger, or a debugger tool: // VS Code debugger export async function loader ( ctx ) { debugger ; // Pause here return { /* ... */ }; }","title":"How do I debug?"},{"location":"faq/#how-do-i-structure-large-projects","text":"Organize by feature: src/ \u251c\u2500\u2500 features/ \u2502 \u251c\u2500\u2500 auth/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 types.ts \u2502 \u251c\u2500\u2500 users/ \u2502 \u2514\u2500\u2500 posts/","title":"How do I structure large projects?"},{"location":"faq/#building-deployment","text":"","title":"Building &amp; Deployment"},{"location":"faq/#whats-the-difference-between-npm-run-build-and-npm-run-dev","text":"npm run dev starts a development server with SSR npm run build generates static HTML files for SSG","title":"What's the difference between npm run build and npm run dev?"},{"location":"faq/#how-do-i-deploy","text":"Static sites (SSG): npm run build # Deploy dist/ to any CDN (Netlify, Vercel, etc.) Server-rendered (SSR): npm run build npm run start # Deploy to Node.js hosting (Heroku, Railway, etc.)","title":"How do I deploy?"},{"location":"faq/#can-i-deploy-to-vercelnetlify","text":"Yes! Use SSG mode to generate static files, then deploy dist/ to either service. For SSR with dynamic routes, deploy to a Node.js compatible platform.","title":"Can I deploy to Vercel/Netlify?"},{"location":"faq/#how-do-i-optimize-for-production","text":"Use SSG when possible Enable minification in jen.config.ts Remove source maps in production Cache static assets on CDN Use HTTP caching headers Monitor bundle size","title":"How do I optimize for production?"},{"location":"faq/#databases","text":"","title":"Databases"},{"location":"faq/#how-do-i-connect-to-a-database","text":"const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } } } };","title":"How do I connect to a database?"},{"location":"faq/#which-database-should-i-use","text":"SQLite \u2014 Development, small projects PostgreSQL \u2014 Production, complex queries MySQL \u2014 Production, shared hosting MongoDB \u2014 Flexible schema, document storage jDB \u2014 Lightweight, embedded","title":"Which database should I use?"},{"location":"faq/#how-do-i-run-migrations","text":"Create migration files and run: npm run migrate","title":"How do I run migrations?"},{"location":"faq/#how-do-i-handle-database-errors","text":"export async function loader ( ctx ) { try { const user = await getUser ( ctx . params . id ); return { user }; } catch ( err ) { ctx . response . writeHead ( 500 ); ctx . response . end ( 'Server error' ); return {}; } }","title":"How do I handle database errors?"},{"location":"faq/#features","text":"","title":"Features"},{"location":"faq/#how-do-i-add-authentication","text":"import { signToken , verifyToken } from '@src/auth/jwt' ; const token = signToken ({ userId : '1' }, '7d' ); const payload = verifyToken ( token );","title":"How do I add authentication?"},{"location":"faq/#how-do-i-use-middleware","text":"Create middleware in src/middleware/ : export async function authMiddleware ( req , res , next ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( 'Unauthorized' ); return ; } next (); }","title":"How do I use middleware?"},{"location":"faq/#how-do-i-add-caching","text":"Configure in jen.config.ts : const config : FrameworkConfig = { cache : { type : 'redis' , config : { url : 'redis://localhost:6379' } } }; Or use HTTP caching headers: export async function loader ( ctx ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); return { /* ... */ }; }","title":"How do I add caching?"},{"location":"faq/#how-do-i-create-a-plugin","text":"Create in src/plugins/ : export default { name : 'my-plugin' , onBuild : async () => { console . log ( 'Building...' ); }, onServe : async () => { console . log ( 'Serving...' ); } };","title":"How do I create a plugin?"},{"location":"faq/#performance","text":"","title":"Performance"},{"location":"faq/#how-can-i-improve-build-speed","text":"Use SSG for static content Avoid heavy computations in loaders Cache API responses Use database indexes","title":"How can I improve build speed?"},{"location":"faq/#how-can-i-improve-runtime-performance","text":"Minimize JavaScript Use SSR for dynamic content Cache responses Optimize database queries Use CDN for static assets","title":"How can I improve runtime performance?"},{"location":"faq/#how-do-i-monitor-performance","text":"export async function loader ( ctx ) { const start = Date . now (); const data = await fetchData (); console . log ( `Took ${ Date . now () - start } ms` ); return { data }; }","title":"How do I monitor performance?"},{"location":"faq/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"faq/#routes-not-working","text":"Check file naming: (name).tsx not name.tsx Ensure files are in site/ directory Restart dev server","title":"Routes not working?"},{"location":"faq/#typescript-errors","text":"Run npm run typecheck Check for missing type definitions Verify tsconfig.json configuration","title":"TypeScript errors?"},{"location":"faq/#build-fails","text":"Check for syntax errors Run npm run typecheck first Check plugin configurations See build output for error details","title":"Build fails?"},{"location":"faq/#dev-server-slow","text":"Check for slow loaders Reduce database queries Use caching Monitor network requests","title":"Dev server slow?"},{"location":"faq/#database-connection-fails","text":"Verify DATABASE_URL in .env Check database is running Check credentials Verify firewall/network access","title":"Database connection fails?"},{"location":"faq/#advanced","text":"","title":"Advanced"},{"location":"faq/#how-do-i-add-typescript-types","text":"Create .d.ts files or use src/types/ : // src/types/global.d.ts declare global { interface Window { myVar : string ; } } export {};","title":"How do I add TypeScript types?"},{"location":"faq/#how-do-i-use-websockets","text":"Currently not directly supported. Use polling or upgrade to a more complex server setup.","title":"How do I use WebSockets?"},{"location":"faq/#how-do-i-add-graphql","text":"Use with API routes: import { graphql } from 'graphql' ; import { schema } from '@src/lib/graphql' ; export async function handle ( req , res ) { const result = await graphql ({ schema , source : req.body }); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( result )); }","title":"How do I add GraphQL?"},{"location":"faq/#how-do-i-extend-the-framework","text":"Create plugins Create custom middleware Create shared components and utilities Use path aliases for imports","title":"How do I extend the framework?"},{"location":"faq/#still-have-questions","text":"Check the full documentation Open an issue on GitHub Ask in discussions","title":"Still Have Questions?"},{"location":"advanced/build/","text":"Understand Jen.js build process for optimization and customization. Build Process npm run build Load configuration from jen.config.ts Scan site/ for routes Run loaders for each route Render components to HTML Bundle and optimize assets Output to dist/ Output Structure dist/ \u251c\u2500\u2500 index/ # Pages \u2502 \u251c\u2500\u2500 index.html # / \u2502 \u251c\u2500\u2500 about/index.html # /about \u2502 \u2514\u2500\u2500 posts/ \u2502 \u251c\u2500\u2500 1/index.html # /posts/1 \u2502 \u2514\u2500\u2500 2/index.html # /posts/2 \u251c\u2500\u2500 assets/ # Static files \u251c\u2500\u2500 styles.css # Global styles \u2514\u2500\u2500 bundle.js # JavaScript bundle Build Configuration In jen.config.ts : const config : FrameworkConfig = { build : { minify : true , sourceMaps : false , splitting : 'auto' , external : [], define : {} } }; Incremental Builds Rebuild specific files: npm run build -- --incremental site/ ( about ) .tsx Build Analysis See what's being built: npm run build -- --verbose Shows: - Routes discovered - Build times - Output file sizes - Asset optimization stats Static Asset Handling Place files in public/ : public/ \u251c\u2500\u2500 favicon.ico \u251c\u2500\u2500 robots.txt \u251c\u2500\u2500 images/ \u2514\u2500\u2500 styles.css Automatically copied to dist/ . Reference in HTML: export default function Home () { return ( < html > < head > < link rel = \"icon\" href = \"/favicon.ico\" /> < /head> < body > < img src = \"/images/logo.png\" alt = \"Logo\" /> < /body> < /html> ); } Code Splitting Split large bundles: const config = { build : { splitting : 'auto' // or 'manual', 'none' } }; Source Maps Enable source maps for debugging: const config = { build : { sourceMaps : true // Development only } }; Environment-Specific Builds NODE_ENV = production npm run build NODE_ENV = staging npm run build Access in config: const config = { build : { minify : process.env.NODE_ENV === 'production' } }; Custom Build Steps Use plugins: // src/plugins/build.ts export default { name : 'custom-build' , onBuild : async ( context ) => { // Custom logic after build await generateMetadata ( context . distDir ); } }; Performance Optimization Image Optimization Use a plugin to compress images during build. Code Minification const config = { build : { minify : true } }; CSS Optimization Unused CSS is automatically removed. Bundle Analysis npm run build -- --analyze Shows bundle composition. Troubleshooting Build Too Slow Check for slow loaders Reduce database queries Cache expensive computations Use incremental builds Large Bundle Use code splitting Remove unused dependencies Check for duplicate packages Run build analysis Memory Issues Build in smaller chunks Use incremental builds Monitor system resources","title":"Build System"},{"location":"advanced/build/#build-process","text":"npm run build Load configuration from jen.config.ts Scan site/ for routes Run loaders for each route Render components to HTML Bundle and optimize assets Output to dist/","title":"Build Process"},{"location":"advanced/build/#output-structure","text":"dist/ \u251c\u2500\u2500 index/ # Pages \u2502 \u251c\u2500\u2500 index.html # / \u2502 \u251c\u2500\u2500 about/index.html # /about \u2502 \u2514\u2500\u2500 posts/ \u2502 \u251c\u2500\u2500 1/index.html # /posts/1 \u2502 \u2514\u2500\u2500 2/index.html # /posts/2 \u251c\u2500\u2500 assets/ # Static files \u251c\u2500\u2500 styles.css # Global styles \u2514\u2500\u2500 bundle.js # JavaScript bundle","title":"Output Structure"},{"location":"advanced/build/#build-configuration","text":"In jen.config.ts : const config : FrameworkConfig = { build : { minify : true , sourceMaps : false , splitting : 'auto' , external : [], define : {} } };","title":"Build Configuration"},{"location":"advanced/build/#incremental-builds","text":"Rebuild specific files: npm run build -- --incremental site/ ( about ) .tsx","title":"Incremental Builds"},{"location":"advanced/build/#build-analysis","text":"See what's being built: npm run build -- --verbose Shows: - Routes discovered - Build times - Output file sizes - Asset optimization stats","title":"Build Analysis"},{"location":"advanced/build/#static-asset-handling","text":"Place files in public/ : public/ \u251c\u2500\u2500 favicon.ico \u251c\u2500\u2500 robots.txt \u251c\u2500\u2500 images/ \u2514\u2500\u2500 styles.css Automatically copied to dist/ . Reference in HTML: export default function Home () { return ( < html > < head > < link rel = \"icon\" href = \"/favicon.ico\" /> < /head> < body > < img src = \"/images/logo.png\" alt = \"Logo\" /> < /body> < /html> ); }","title":"Static Asset Handling"},{"location":"advanced/build/#code-splitting","text":"Split large bundles: const config = { build : { splitting : 'auto' // or 'manual', 'none' } };","title":"Code Splitting"},{"location":"advanced/build/#source-maps","text":"Enable source maps for debugging: const config = { build : { sourceMaps : true // Development only } };","title":"Source Maps"},{"location":"advanced/build/#environment-specific-builds","text":"NODE_ENV = production npm run build NODE_ENV = staging npm run build Access in config: const config = { build : { minify : process.env.NODE_ENV === 'production' } };","title":"Environment-Specific Builds"},{"location":"advanced/build/#custom-build-steps","text":"Use plugins: // src/plugins/build.ts export default { name : 'custom-build' , onBuild : async ( context ) => { // Custom logic after build await generateMetadata ( context . distDir ); } };","title":"Custom Build Steps"},{"location":"advanced/build/#performance-optimization","text":"","title":"Performance Optimization"},{"location":"advanced/build/#image-optimization","text":"Use a plugin to compress images during build.","title":"Image Optimization"},{"location":"advanced/build/#code-minification","text":"const config = { build : { minify : true } };","title":"Code Minification"},{"location":"advanced/build/#css-optimization","text":"Unused CSS is automatically removed.","title":"CSS Optimization"},{"location":"advanced/build/#bundle-analysis","text":"npm run build -- --analyze Shows bundle composition.","title":"Bundle Analysis"},{"location":"advanced/build/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"advanced/build/#build-too-slow","text":"Check for slow loaders Reduce database queries Cache expensive computations Use incremental builds","title":"Build Too Slow"},{"location":"advanced/build/#large-bundle","text":"Use code splitting Remove unused dependencies Check for duplicate packages Run build analysis","title":"Large Bundle"},{"location":"advanced/build/#memory-issues","text":"Build in smaller chunks Use incremental builds Monitor system resources","title":"Memory Issues"},{"location":"advanced/native/","text":"Jen.js supports native modules written in Rust/C++ for high-performance operations. Current Status TypeScript stubs currently in src/native/ : Module Current Production dev-server.ts Node.js Rust (Tokio) bundler.ts esbuild wrapper C++ style-compiler.ts Stub Rust optimizer.ts Stub Rust Using Native Modules Native modules are compatible with TypeScript. Use them like any other module: import { bundler } from '@src/native/bundler' ; const output = await bundler . build ({ entry : 'src/index.ts' , output : 'dist/bundle.js' }); Building Native Modules Rust Example native/bundler/src/lib.rs #[napi] pub fn bundle ( entry : String ) -> napi :: Result < String > { // Bundle implementation Ok ( format! ( \"Bundled {}\" , entry )) } C++ Example native/optimizer/index.cpp #include <node.h> void Optimize ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ) { // Optimization logic } NODE_SET_METHOD ( exports , \"optimize\" , Optimize ); Development vs Production Development uses TypeScript stubs for fast iteration: npm run dev # Uses stub implementations Production uses native bindings: npm run build # Uses native modules Performance Benefits Native modules improve: - Build time (10-50x faster bundling) - Runtime performance (3-5x faster optimization) - Memory efficiency - Startup time Custom Native Modules Create your own native module: Write Rust/C++ implementation Create TypeScript wrapper Register in src/native/ Use in your code import { customModule } from '@src/native/custom' ; const result = await customModule . process ( data ); Building Native Bindings # Setup build environment npm install # Build native modules cargo build --release # Copy to dist cp -r native/target/release/*.node dist/ Next Steps Explore existing native modules Consider native optimization for your needs Contribute native implementations","title":"Native Modules"},{"location":"advanced/native/#current-status","text":"TypeScript stubs currently in src/native/ : Module Current Production dev-server.ts Node.js Rust (Tokio) bundler.ts esbuild wrapper C++ style-compiler.ts Stub Rust optimizer.ts Stub Rust","title":"Current Status"},{"location":"advanced/native/#using-native-modules","text":"Native modules are compatible with TypeScript. Use them like any other module: import { bundler } from '@src/native/bundler' ; const output = await bundler . build ({ entry : 'src/index.ts' , output : 'dist/bundle.js' });","title":"Using Native Modules"},{"location":"advanced/native/#building-native-modules","text":"","title":"Building Native Modules"},{"location":"advanced/native/#rust-example","text":"native/bundler/src/lib.rs #[napi] pub fn bundle ( entry : String ) -> napi :: Result < String > { // Bundle implementation Ok ( format! ( \"Bundled {}\" , entry )) }","title":"Rust Example"},{"location":"advanced/native/#c-example","text":"native/optimizer/index.cpp #include <node.h> void Optimize ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ) { // Optimization logic } NODE_SET_METHOD ( exports , \"optimize\" , Optimize );","title":"C++ Example"},{"location":"advanced/native/#development-vs-production","text":"Development uses TypeScript stubs for fast iteration: npm run dev # Uses stub implementations Production uses native bindings: npm run build # Uses native modules","title":"Development vs Production"},{"location":"advanced/native/#performance-benefits","text":"Native modules improve: - Build time (10-50x faster bundling) - Runtime performance (3-5x faster optimization) - Memory efficiency - Startup time","title":"Performance Benefits"},{"location":"advanced/native/#custom-native-modules","text":"Create your own native module: Write Rust/C++ implementation Create TypeScript wrapper Register in src/native/ Use in your code import { customModule } from '@src/native/custom' ; const result = await customModule . process ( data );","title":"Custom Native Modules"},{"location":"advanced/native/#building-native-bindings","text":"# Setup build environment npm install # Build native modules cargo build --release # Copy to dist cp -r native/target/release/*.node dist/","title":"Building Native Bindings"},{"location":"advanced/native/#next-steps","text":"Explore existing native modules Consider native optimization for your needs Contribute native implementations","title":"Next Steps"},{"location":"advanced/performance/","text":"Optimize your Jen.js application for speed and efficiency. Build Performance Faster Builds Use incremental builds: npm run build -- --incremental Only rebuilds changed routes. Caching Enable build caching: const config = { cache : { enabled : true , dir : '.jen-cache' } }; Parallel Builds Jen.js automatically parallelizes: - Route compilation - Asset processing - Page rendering Adjust workers: const config = { build : { workers : 4 // CPU cores } }; Runtime Performance Minimize JavaScript // Only load interactivity when needed const Counter = lazy (() => import ( './counter.tsx' )); export default function Page () { return ( < html > < head >< title > Page < /title></head> < body > < Suspense fallback = { < div > Loading ... < /div>}> < Counter /> < /Suspense> < /body> < /html> ); } Use SSG When Possible Pre-build static pages: // site/(about).tsx export const mode = 'ssg' ; // Pre-render export default function About () { return < h1 > About < /h1>; } Cache Database Queries const cache = new Map (); async function getCachedUser ( id ) { if ( cache . has ( id )) { return cache . get ( id ); } const user = await db . findOne ( 'users' , { id }); cache . set ( id , user ); // Invalidate after 5 minutes setTimeout (() => cache . delete ( id ), 300000 ); return user ; } Use HTTP Caching export async function loader ( ctx ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); return { data : await fetchData () }; } Database Optimization Use Indexes await db . exec ( 'CREATE INDEX idx_email ON users(email)' ); Connection Pooling const config = { database : { default : { pool : { min : 2 , max : 10 } } } }; Query Optimization // Good: Single query const user = await db . findOne ( 'users' , { id : 1 }); // Bad: Multiple queries (N+1) const users = await db . find ( 'users' , {}); for ( const user of users ) { user . profile = await db . findOne ( 'profiles' , { userId : user.id }); } Bundle Size Check Bundle Size npm run build -- --analyze Remove Unused Code Tree-shaking removes unused exports: // Good: Named imports import { Component } from '@src/components' ; // Avoid: Namespace imports import * as Components from '@src/components' ; Lazy Loading import { lazy , Suspense } from 'preact/compat' ; const HeavyComponent = lazy (() => import ( './heavy.tsx' )); export default function App () { return ( < Suspense fallback = { < div > Loading ... < /div>}> < HeavyComponent /> < /Suspense> ); } Compression Enable gzip compression: // src/middleware/compression.ts import { createGzip } from 'node:zlib' ; export function compressionMiddleware ( req , res , next ) { if ( /gzip/ . test ( req . headers [ 'accept-encoding' ] || '' )) { res . setHeader ( 'Content-Encoding' , 'gzip' ); const gzip = createGzip (); gzip . pipe ( res ); res . write = ( chunk ) => gzip . write ( chunk ); res . end = ( chunk ) => gzip . end ( chunk ); } next (); } Monitoring Build Time Tracking npm run build -- --verbose --time Shows timing for each phase. Runtime Monitoring export async function loader ( ctx ) { const start = Date . now (); const data = await fetchData (); const duration = Date . now () - start ; console . log ( `Loader took ${ duration } ms` ); return { data }; } Memory Profiling node --inspect build.js # Open chrome://inspect CDN Configuration export async function loader ( ctx ) { // Enable browser caching ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=31536000' ); // Version static assets // /assets/bundle-abc123.js return { /* ... */ }; } Performance Checklist Use SSG for static content Enable HTTP caching Minify production builds Use database indexes Implement query caching Compress responses Use CDN for assets Monitor build times Track runtime performance Profile memory usage Remove unused dependencies Use lazy loading for heavy components Implement rate limiting Use pagination for large data Monitor error rates Profiling Tools Node.js Profiler node --prof build.js node --prof-process isolate-*.log > profile.txt Clinic.js npm install -g clinic clinic doctor -- npm run build Artillery Load testing: npm install -g artillery artillery quick --count 10 --num 100 http://localhost:3000 Best Practices Measure before optimizing Focus on bottlenecks Use caching strategically Optimize database queries Monitor in production Test performance regularly Use appropriate compression Implement pagination Use CDN for static assets Profile regularly","title":"Performance"},{"location":"advanced/performance/#build-performance","text":"","title":"Build Performance"},{"location":"advanced/performance/#faster-builds","text":"Use incremental builds: npm run build -- --incremental Only rebuilds changed routes.","title":"Faster Builds"},{"location":"advanced/performance/#caching","text":"Enable build caching: const config = { cache : { enabled : true , dir : '.jen-cache' } };","title":"Caching"},{"location":"advanced/performance/#parallel-builds","text":"Jen.js automatically parallelizes: - Route compilation - Asset processing - Page rendering Adjust workers: const config = { build : { workers : 4 // CPU cores } };","title":"Parallel Builds"},{"location":"advanced/performance/#runtime-performance","text":"","title":"Runtime Performance"},{"location":"advanced/performance/#minimize-javascript","text":"// Only load interactivity when needed const Counter = lazy (() => import ( './counter.tsx' )); export default function Page () { return ( < html > < head >< title > Page < /title></head> < body > < Suspense fallback = { < div > Loading ... < /div>}> < Counter /> < /Suspense> < /body> < /html> ); }","title":"Minimize JavaScript"},{"location":"advanced/performance/#use-ssg-when-possible","text":"Pre-build static pages: // site/(about).tsx export const mode = 'ssg' ; // Pre-render export default function About () { return < h1 > About < /h1>; }","title":"Use SSG When Possible"},{"location":"advanced/performance/#cache-database-queries","text":"const cache = new Map (); async function getCachedUser ( id ) { if ( cache . has ( id )) { return cache . get ( id ); } const user = await db . findOne ( 'users' , { id }); cache . set ( id , user ); // Invalidate after 5 minutes setTimeout (() => cache . delete ( id ), 300000 ); return user ; }","title":"Cache Database Queries"},{"location":"advanced/performance/#use-http-caching","text":"export async function loader ( ctx ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); return { data : await fetchData () }; }","title":"Use HTTP Caching"},{"location":"advanced/performance/#database-optimization","text":"","title":"Database Optimization"},{"location":"advanced/performance/#use-indexes","text":"await db . exec ( 'CREATE INDEX idx_email ON users(email)' );","title":"Use Indexes"},{"location":"advanced/performance/#connection-pooling","text":"const config = { database : { default : { pool : { min : 2 , max : 10 } } } };","title":"Connection Pooling"},{"location":"advanced/performance/#query-optimization","text":"// Good: Single query const user = await db . findOne ( 'users' , { id : 1 }); // Bad: Multiple queries (N+1) const users = await db . find ( 'users' , {}); for ( const user of users ) { user . profile = await db . findOne ( 'profiles' , { userId : user.id }); }","title":"Query Optimization"},{"location":"advanced/performance/#bundle-size","text":"","title":"Bundle Size"},{"location":"advanced/performance/#check-bundle-size","text":"npm run build -- --analyze","title":"Check Bundle Size"},{"location":"advanced/performance/#remove-unused-code","text":"Tree-shaking removes unused exports: // Good: Named imports import { Component } from '@src/components' ; // Avoid: Namespace imports import * as Components from '@src/components' ;","title":"Remove Unused Code"},{"location":"advanced/performance/#lazy-loading","text":"import { lazy , Suspense } from 'preact/compat' ; const HeavyComponent = lazy (() => import ( './heavy.tsx' )); export default function App () { return ( < Suspense fallback = { < div > Loading ... < /div>}> < HeavyComponent /> < /Suspense> ); }","title":"Lazy Loading"},{"location":"advanced/performance/#compression","text":"Enable gzip compression: // src/middleware/compression.ts import { createGzip } from 'node:zlib' ; export function compressionMiddleware ( req , res , next ) { if ( /gzip/ . test ( req . headers [ 'accept-encoding' ] || '' )) { res . setHeader ( 'Content-Encoding' , 'gzip' ); const gzip = createGzip (); gzip . pipe ( res ); res . write = ( chunk ) => gzip . write ( chunk ); res . end = ( chunk ) => gzip . end ( chunk ); } next (); }","title":"Compression"},{"location":"advanced/performance/#monitoring","text":"","title":"Monitoring"},{"location":"advanced/performance/#build-time-tracking","text":"npm run build -- --verbose --time Shows timing for each phase.","title":"Build Time Tracking"},{"location":"advanced/performance/#runtime-monitoring","text":"export async function loader ( ctx ) { const start = Date . now (); const data = await fetchData (); const duration = Date . now () - start ; console . log ( `Loader took ${ duration } ms` ); return { data }; }","title":"Runtime Monitoring"},{"location":"advanced/performance/#memory-profiling","text":"node --inspect build.js # Open chrome://inspect","title":"Memory Profiling"},{"location":"advanced/performance/#cdn-configuration","text":"export async function loader ( ctx ) { // Enable browser caching ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=31536000' ); // Version static assets // /assets/bundle-abc123.js return { /* ... */ }; }","title":"CDN Configuration"},{"location":"advanced/performance/#performance-checklist","text":"Use SSG for static content Enable HTTP caching Minify production builds Use database indexes Implement query caching Compress responses Use CDN for assets Monitor build times Track runtime performance Profile memory usage Remove unused dependencies Use lazy loading for heavy components Implement rate limiting Use pagination for large data Monitor error rates","title":"Performance Checklist"},{"location":"advanced/performance/#profiling-tools","text":"","title":"Profiling Tools"},{"location":"advanced/performance/#nodejs-profiler","text":"node --prof build.js node --prof-process isolate-*.log > profile.txt","title":"Node.js Profiler"},{"location":"advanced/performance/#clinicjs","text":"npm install -g clinic clinic doctor -- npm run build","title":"Clinic.js"},{"location":"advanced/performance/#artillery","text":"Load testing: npm install -g artillery artillery quick --count 10 --num 100 http://localhost:3000","title":"Artillery"},{"location":"advanced/performance/#best-practices","text":"Measure before optimizing Focus on bottlenecks Use caching strategically Optimize database queries Monitor in production Test performance regularly Use appropriate compression Implement pagination Use CDN for static assets Profile regularly","title":"Best Practices"},{"location":"api/auth/","text":"JWT authentication utilities in Jen.js. signToken() Create a JWT token: import { signToken } from '@src/auth/jwt' ; const token = signToken ( payload , expiresIn , options ); Parameters interface TokenPayload { [ key : string ] : any ; } // Payload - data to encode const payload = { userId : '123' , email : 'user@example.com' , role : 'admin' }; // Expiration time const expiresIn = '7d' ; // 7 days // or '24h', '3600s', or number (seconds) // Optional options const options = { issuer : 'your-app' , audience : 'your-app' , algorithm : 'HS256' }; const token = signToken ( payload , expiresIn , options ); Examples // Simple token const token = signToken ({ userId : '1' }, '7d' ); // Complex payload const token = signToken ({ userId : '123' , email : 'alice@example.com' , role : 'admin' , permissions : [ 'read' , 'write' ] }, '24h' ); // Custom options const token = signToken ( { userId : '1' }, '30d' , { issuer : 'my-app' , audience : 'web-client' } ); verifyToken() Verify and decode a JWT: import { verifyToken } from '@src/auth/jwt' ; try { const payload = verifyToken ( token ); console . log ( payload . userId ); } catch ( err ) { console . error ( 'Invalid token' ); } Returns interface Payload { [ key : string ] : any ; iat? : number ; // Issued at exp? : number ; // Expiration time iss? : string ; // Issuer aud? : string ; // Audience } const payload = verifyToken ( token ); // { userId: '123', email: '...', iat: 1234567890, exp: ... } Error Handling try { const payload = verifyToken ( token ); } catch ( err ) { if ( err . name === 'TokenExpiredError' ) { console . error ( 'Token expired' ); } else if ( err . name === 'JsonWebTokenError' ) { console . error ( 'Invalid token' ); } else { console . error ( 'Unknown error:' , err ); } } Usage Examples Login Route // site/api/(login).ts import { signToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const { email , password } = JSON . parse ( body ); // Verify credentials const user = await verifyCredentials ( email , password ); if ( user ) { const token = signToken ( { userId : user.id , email : user.email , role : user.role }, '7d' ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ token , user })); } else { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'Invalid credentials' })); } }); } } Protected Route // site/dashboard/($userId).tsx import { verifyToken } from '@src/auth/jwt' ; export async function loader ( ctx ) { const token = ctx . request . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } try { const payload = verifyToken ( token ); const user = await getUser ( payload . userId ); return { user }; } catch ( err ) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } } export default function Dashboard ({ user } : any ) { return < h1 > Welcome , { user . email } < /h1>; } Protected API // site/api/(profile).ts import { verifyToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'No token' })); return ; } try { const payload = verifyToken ( token ); const user = await getUser ( payload . userId ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( user )); } catch ( err ) { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'Invalid token' })); } } Refresh Tokens // site/api/(refresh).ts import { signToken , verifyToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const { refreshToken } = JSON . parse ( body ); try { const payload = verifyToken ( refreshToken ); // Issue new token const newToken = signToken ( { userId : payload.userId }, '7d' ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ token : newToken })); } catch ( err ) { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'Invalid refresh token' })); } }); } } Configuration In jen.config.ts : const config : FrameworkConfig = { auth : { secret : process.env.JWT_SECRET || 'dev-secret' , algorithm : 'HS256' , issuer : 'your-app' , audience : 'your-app' } }; Token Expiration Recommended TTLs: Access token: 15 minutes to 1 hour Refresh token: 7-30 days Long-lived: 90+ days // Short-lived access token const accessToken = signToken ( payload , '15m' ); // Long-lived refresh token const refreshToken = signToken ( payload , '30d' ); Security Best Practices Use environment variables for secrets: JWT_SECRET=your-secret-key Use HTTPS in production to prevent token interception Store tokens securely on client: // Good: httpOnly cookie (can't access via JS) // Bad: localStorage (vulnerable to XSS) Short expiration for access tokens Validate token signature on every request Implement logout by invalidating tokens Use refresh tokens for long sessions Rotate secrets periodically Rate limit login attempts Log auth events for security audit Token Structure JWT consists of 3 parts (header.payload.signature): // Header { \"alg\" : \"HS256\" , \"typ\" : \"JWT\" } // Payload (your data) { \"userId\" : \"123\" , \"iat\" : 1234567890 , \"exp\" : 1234571490 } // Signature (verification) base64 ( HMAC - SHA256 ( header . payload , secret )) The full token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJ1c2VySWQiOiIxMjMifQ. SIGNATURE Algorithms Supported algorithms: HS256 (HMAC) \u2014 Symmetric, uses shared secret RS256 (RSA) \u2014 Asymmetric, uses public/private keys // Symmetric (default) const token = signToken ( payload , '7d' ); // Uses secret // Asymmetric (if configured) const token = signToken ( payload , '7d' , { algorithm : 'RS256' , privateKey : process.env.PRIVATE_KEY }); Debugging import { verifyToken } from '@src/auth/jwt' ; import jwt from 'jsonwebtoken' ; const token = 'your-token...' ; // Decode without verification const decoded = jwt . decode ( token ); console . log ( 'Decoded:' , decoded ); // Verify with detailed error try { const payload = verifyToken ( token ); } catch ( err ) { console . error ( 'Error:' , err . message ); console . error ( 'Name:' , err . name ); }","title":"Auth API"},{"location":"api/auth/#signtoken","text":"Create a JWT token: import { signToken } from '@src/auth/jwt' ; const token = signToken ( payload , expiresIn , options );","title":"signToken()"},{"location":"api/auth/#parameters","text":"interface TokenPayload { [ key : string ] : any ; } // Payload - data to encode const payload = { userId : '123' , email : 'user@example.com' , role : 'admin' }; // Expiration time const expiresIn = '7d' ; // 7 days // or '24h', '3600s', or number (seconds) // Optional options const options = { issuer : 'your-app' , audience : 'your-app' , algorithm : 'HS256' }; const token = signToken ( payload , expiresIn , options );","title":"Parameters"},{"location":"api/auth/#examples","text":"// Simple token const token = signToken ({ userId : '1' }, '7d' ); // Complex payload const token = signToken ({ userId : '123' , email : 'alice@example.com' , role : 'admin' , permissions : [ 'read' , 'write' ] }, '24h' ); // Custom options const token = signToken ( { userId : '1' }, '30d' , { issuer : 'my-app' , audience : 'web-client' } );","title":"Examples"},{"location":"api/auth/#verifytoken","text":"Verify and decode a JWT: import { verifyToken } from '@src/auth/jwt' ; try { const payload = verifyToken ( token ); console . log ( payload . userId ); } catch ( err ) { console . error ( 'Invalid token' ); }","title":"verifyToken()"},{"location":"api/auth/#returns","text":"interface Payload { [ key : string ] : any ; iat? : number ; // Issued at exp? : number ; // Expiration time iss? : string ; // Issuer aud? : string ; // Audience } const payload = verifyToken ( token ); // { userId: '123', email: '...', iat: 1234567890, exp: ... }","title":"Returns"},{"location":"api/auth/#error-handling","text":"try { const payload = verifyToken ( token ); } catch ( err ) { if ( err . name === 'TokenExpiredError' ) { console . error ( 'Token expired' ); } else if ( err . name === 'JsonWebTokenError' ) { console . error ( 'Invalid token' ); } else { console . error ( 'Unknown error:' , err ); } }","title":"Error Handling"},{"location":"api/auth/#usage-examples","text":"","title":"Usage Examples"},{"location":"api/auth/#login-route","text":"// site/api/(login).ts import { signToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const { email , password } = JSON . parse ( body ); // Verify credentials const user = await verifyCredentials ( email , password ); if ( user ) { const token = signToken ( { userId : user.id , email : user.email , role : user.role }, '7d' ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ token , user })); } else { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'Invalid credentials' })); } }); } }","title":"Login Route"},{"location":"api/auth/#protected-route","text":"// site/dashboard/($userId).tsx import { verifyToken } from '@src/auth/jwt' ; export async function loader ( ctx ) { const token = ctx . request . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } try { const payload = verifyToken ( token ); const user = await getUser ( payload . userId ); return { user }; } catch ( err ) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } } export default function Dashboard ({ user } : any ) { return < h1 > Welcome , { user . email } < /h1>; }","title":"Protected Route"},{"location":"api/auth/#protected-api","text":"// site/api/(profile).ts import { verifyToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'No token' })); return ; } try { const payload = verifyToken ( token ); const user = await getUser ( payload . userId ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( user )); } catch ( err ) { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'Invalid token' })); } }","title":"Protected API"},{"location":"api/auth/#refresh-tokens","text":"// site/api/(refresh).ts import { signToken , verifyToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const { refreshToken } = JSON . parse ( body ); try { const payload = verifyToken ( refreshToken ); // Issue new token const newToken = signToken ( { userId : payload.userId }, '7d' ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ token : newToken })); } catch ( err ) { res . writeHead ( 401 ); res . end ( JSON . stringify ({ error : 'Invalid refresh token' })); } }); } }","title":"Refresh Tokens"},{"location":"api/auth/#configuration","text":"In jen.config.ts : const config : FrameworkConfig = { auth : { secret : process.env.JWT_SECRET || 'dev-secret' , algorithm : 'HS256' , issuer : 'your-app' , audience : 'your-app' } };","title":"Configuration"},{"location":"api/auth/#token-expiration","text":"Recommended TTLs: Access token: 15 minutes to 1 hour Refresh token: 7-30 days Long-lived: 90+ days // Short-lived access token const accessToken = signToken ( payload , '15m' ); // Long-lived refresh token const refreshToken = signToken ( payload , '30d' );","title":"Token Expiration"},{"location":"api/auth/#security-best-practices","text":"Use environment variables for secrets: JWT_SECRET=your-secret-key Use HTTPS in production to prevent token interception Store tokens securely on client: // Good: httpOnly cookie (can't access via JS) // Bad: localStorage (vulnerable to XSS) Short expiration for access tokens Validate token signature on every request Implement logout by invalidating tokens Use refresh tokens for long sessions Rotate secrets periodically Rate limit login attempts Log auth events for security audit","title":"Security Best Practices"},{"location":"api/auth/#token-structure","text":"JWT consists of 3 parts (header.payload.signature): // Header { \"alg\" : \"HS256\" , \"typ\" : \"JWT\" } // Payload (your data) { \"userId\" : \"123\" , \"iat\" : 1234567890 , \"exp\" : 1234571490 } // Signature (verification) base64 ( HMAC - SHA256 ( header . payload , secret )) The full token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJ1c2VySWQiOiIxMjMifQ. SIGNATURE","title":"Token Structure"},{"location":"api/auth/#algorithms","text":"Supported algorithms: HS256 (HMAC) \u2014 Symmetric, uses shared secret RS256 (RSA) \u2014 Asymmetric, uses public/private keys // Symmetric (default) const token = signToken ( payload , '7d' ); // Uses secret // Asymmetric (if configured) const token = signToken ( payload , '7d' , { algorithm : 'RS256' , privateKey : process.env.PRIVATE_KEY });","title":"Algorithms"},{"location":"api/auth/#debugging","text":"import { verifyToken } from '@src/auth/jwt' ; import jwt from 'jsonwebtoken' ; const token = 'your-token...' ; // Decode without verification const decoded = jwt . decode ( token ); console . log ( 'Decoded:' , decoded ); // Verify with detailed error try { const payload = verifyToken ( token ); } catch ( err ) { console . error ( 'Error:' , err . message ); console . error ( 'Name:' , err . name ); }","title":"Debugging"},{"location":"api/config/","text":"Complete reference for jen.config.ts options. Type Definition interface FrameworkConfig { siteDir? : string ; distDir? : string ; publicDir? : string ; cacheDir? : string ; rendering? : RenderingConfig ; routes? : RoutesConfig ; build? : BuildConfig ; server? : ServerConfig ; database? : DatabaseConfig ; auth? : AuthConfig ; plugins? : PluginConfig []; middleware? : MiddlewareConfig []; typescript? : TypeScriptConfig ; } Directories { siteDir : 'site' , // Source routes distDir : 'dist' , // Build output publicDir : 'public' , // Static assets cacheDir : '.jen-cache' // Cache location } Rendering { rendering : { defaultMode : 'ssr' | 'ssg' , // Default rendering defaultRevalidateSeconds : 60 , // Revalidation (SSG) hydrate : true , // Client hydration cssFramework : 'none' // CSS solution } } Routes { routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true , caseSensitive : false } } Build { build : { minify : true , // Minify output sourceMaps : false , // Generate maps splitting : 'auto' | 'manual' | 'none' , external : [ 'express' ], // Don't bundle define : { // Inline constants __VERSION__ : '\"1.0.0\"' }, workers : 4 // Build workers } } Server { server : { host : '0.0.0.0' , port : 3000 , cors : { origin : '*' , credentials : true , methods : [ 'GET' , 'POST' , 'PUT' , 'DELETE' ], allowedHeaders : [ 'Content-Type' ] }, timeout : 30000 , // Request timeout (ms) bodySizeLimit : '10mb' } } Database { database : { default : { type : 'sqlite' | 'postgres' | 'mysql' | 'mongodb' | 'jdb' , config : { // Type-specific config } }, connections : { cache : { /* ... */ }, search : { /* ... */ } } } } SQLite Config { type : 'sqlite' , config : { filename : './data.db' } } PostgreSQL Config { type : 'postgres' , config : { host : 'localhost' , port : 5432 , database : 'myapp' , user : 'postgres' , password : 'secret' , // OR connectionString : 'postgresql://...' } } MySQL Config { type : 'mysql' , config : { host : 'localhost' , user : 'root' , password : 'secret' , database : 'myapp' } } MongoDB Config { type : 'mongodb' , config : { url : 'mongodb://localhost:27017/myapp' } } jDB Config { type : 'jdb' , config : { root : './data' , name : 'app' } } Authentication { auth : { secret : process.env.JWT_SECRET , algorithm : 'HS256' | 'RS256' , issuer : 'your-app' , audience : 'your-app' , expiresIn : '7d' } } Plugins { plugins : [ '@jen/plugin-analytics' , './src/plugins/custom.ts' , createCustomPlugin ({ option : 'value' }) ] } Middleware { middleware : [ corsMiddleware , compressionMiddleware , authMiddleware ] } TypeScript { typescript : { typeCheck : true , // Check during build strict : true , // Strict mode target : 'ES2022' , lib : [ 'ES2022' ], jsx : 'react-jsx' , jsxImportSource : 'preact' } } Environment-Specific Config import type { FrameworkConfig } from '@src/core/config' ; const isDev = process . env . NODE_ENV === 'development' ; const isProd = process . env . NODE_ENV === 'production' ; const config : FrameworkConfig = { rendering : { defaultMode : isProd ? 'ssg' : 'ssr' }, build : { minify : isProd , sourceMaps : isDev }, server : { port : parseInt ( process . env . PORT || '3000' ) } }; export default config ; Per-Route Overrides In route files: // site/(home).tsx export const mode = 'ssg' ; // Override rendering mode export const revalidate = 3600 ; // Revalidation (seconds) export const meta = { title : 'Home' , description : 'Welcome' }; Configuration Validation Configuration is validated on startup: Error: Unknown configuration key \"invalidKey\" Check jen.config.ts for typos or unsupported options. Default Values const defaults = { siteDir : 'site' , distDir : 'dist' , publicDir : 'public' , cacheDir : '.jen-cache' , rendering : { defaultMode : 'ssr' , defaultRevalidateSeconds : 60 , hydrate : true , cssFramework : 'none' }, routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true , caseSensitive : false }, build : { minify : true , sourceMaps : false , splitting : 'auto' , external : [], workers : availableCpus }, server : { host : '0.0.0.0' , port : 3000 , timeout : 30000 , bodySizeLimit : '10mb' } };","title":"Framework Config"},{"location":"api/config/#type-definition","text":"interface FrameworkConfig { siteDir? : string ; distDir? : string ; publicDir? : string ; cacheDir? : string ; rendering? : RenderingConfig ; routes? : RoutesConfig ; build? : BuildConfig ; server? : ServerConfig ; database? : DatabaseConfig ; auth? : AuthConfig ; plugins? : PluginConfig []; middleware? : MiddlewareConfig []; typescript? : TypeScriptConfig ; }","title":"Type Definition"},{"location":"api/config/#directories","text":"{ siteDir : 'site' , // Source routes distDir : 'dist' , // Build output publicDir : 'public' , // Static assets cacheDir : '.jen-cache' // Cache location }","title":"Directories"},{"location":"api/config/#rendering","text":"{ rendering : { defaultMode : 'ssr' | 'ssg' , // Default rendering defaultRevalidateSeconds : 60 , // Revalidation (SSG) hydrate : true , // Client hydration cssFramework : 'none' // CSS solution } }","title":"Rendering"},{"location":"api/config/#routes","text":"{ routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true , caseSensitive : false } }","title":"Routes"},{"location":"api/config/#build","text":"{ build : { minify : true , // Minify output sourceMaps : false , // Generate maps splitting : 'auto' | 'manual' | 'none' , external : [ 'express' ], // Don't bundle define : { // Inline constants __VERSION__ : '\"1.0.0\"' }, workers : 4 // Build workers } }","title":"Build"},{"location":"api/config/#server","text":"{ server : { host : '0.0.0.0' , port : 3000 , cors : { origin : '*' , credentials : true , methods : [ 'GET' , 'POST' , 'PUT' , 'DELETE' ], allowedHeaders : [ 'Content-Type' ] }, timeout : 30000 , // Request timeout (ms) bodySizeLimit : '10mb' } }","title":"Server"},{"location":"api/config/#database","text":"{ database : { default : { type : 'sqlite' | 'postgres' | 'mysql' | 'mongodb' | 'jdb' , config : { // Type-specific config } }, connections : { cache : { /* ... */ }, search : { /* ... */ } } } }","title":"Database"},{"location":"api/config/#sqlite-config","text":"{ type : 'sqlite' , config : { filename : './data.db' } }","title":"SQLite Config"},{"location":"api/config/#postgresql-config","text":"{ type : 'postgres' , config : { host : 'localhost' , port : 5432 , database : 'myapp' , user : 'postgres' , password : 'secret' , // OR connectionString : 'postgresql://...' } }","title":"PostgreSQL Config"},{"location":"api/config/#mysql-config","text":"{ type : 'mysql' , config : { host : 'localhost' , user : 'root' , password : 'secret' , database : 'myapp' } }","title":"MySQL Config"},{"location":"api/config/#mongodb-config","text":"{ type : 'mongodb' , config : { url : 'mongodb://localhost:27017/myapp' } }","title":"MongoDB Config"},{"location":"api/config/#jdb-config","text":"{ type : 'jdb' , config : { root : './data' , name : 'app' } }","title":"jDB Config"},{"location":"api/config/#authentication","text":"{ auth : { secret : process.env.JWT_SECRET , algorithm : 'HS256' | 'RS256' , issuer : 'your-app' , audience : 'your-app' , expiresIn : '7d' } }","title":"Authentication"},{"location":"api/config/#plugins","text":"{ plugins : [ '@jen/plugin-analytics' , './src/plugins/custom.ts' , createCustomPlugin ({ option : 'value' }) ] }","title":"Plugins"},{"location":"api/config/#middleware","text":"{ middleware : [ corsMiddleware , compressionMiddleware , authMiddleware ] }","title":"Middleware"},{"location":"api/config/#typescript","text":"{ typescript : { typeCheck : true , // Check during build strict : true , // Strict mode target : 'ES2022' , lib : [ 'ES2022' ], jsx : 'react-jsx' , jsxImportSource : 'preact' } }","title":"TypeScript"},{"location":"api/config/#environment-specific-config","text":"import type { FrameworkConfig } from '@src/core/config' ; const isDev = process . env . NODE_ENV === 'development' ; const isProd = process . env . NODE_ENV === 'production' ; const config : FrameworkConfig = { rendering : { defaultMode : isProd ? 'ssg' : 'ssr' }, build : { minify : isProd , sourceMaps : isDev }, server : { port : parseInt ( process . env . PORT || '3000' ) } }; export default config ;","title":"Environment-Specific Config"},{"location":"api/config/#per-route-overrides","text":"In route files: // site/(home).tsx export const mode = 'ssg' ; // Override rendering mode export const revalidate = 3600 ; // Revalidation (seconds) export const meta = { title : 'Home' , description : 'Welcome' };","title":"Per-Route Overrides"},{"location":"api/config/#configuration-validation","text":"Configuration is validated on startup: Error: Unknown configuration key \"invalidKey\" Check jen.config.ts for typos or unsupported options.","title":"Configuration Validation"},{"location":"api/config/#default-values","text":"const defaults = { siteDir : 'site' , distDir : 'dist' , publicDir : 'public' , cacheDir : '.jen-cache' , rendering : { defaultMode : 'ssr' , defaultRevalidateSeconds : 60 , hydrate : true , cssFramework : 'none' }, routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true , caseSensitive : false }, build : { minify : true , sourceMaps : false , splitting : 'auto' , external : [], workers : availableCpus }, server : { host : '0.0.0.0' , port : 3000 , timeout : 30000 , bodySizeLimit : '10mb' } };","title":"Default Values"},{"location":"api/database/","text":"Complete reference for database operations in Jen.js. DB Class import { DB } from '@src/db' ; const db = new DB ({ type : 'sqlite' }); await db . connect (); Methods connect() Initialize database connection: const db = new DB ( config ); await db . connect (); disconnect() Close connection: await db . disconnect (); insert() Add new record: const result = await db . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); // Returns { id: 1, ... } find() Query multiple records: const users = await db . find ( 'users' , { active : true }); const results = await db . find ( 'users' , { name : { $startsWith : 'A' } }); findOne() Get single record: const user = await db . findOne ( 'users' , { id : 1 }); // Returns user object or null update() Modify records: await db . update ( 'users' , { id : 1 }, // Filter { name : 'Bob' , active : true } // Updates ); delete() Remove records: await db . delete ( 'users' , { id : 1 }); count() Count records: const total = await db . count ( 'users' , {}); const active = await db . count ( 'users' , { active : true }); exec() Execute raw SQL: await db . exec ( ` CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL ) ` ); transaction() Atomic operations: await db . transaction ( async ( tx ) => { await tx . insert ( 'users' , { name : 'Alice' }); await tx . insert ( 'profiles' , { userId : 1 }); }); All changes committed or rolled back together. Query Operators Comparison // Equals db . find ( 'users' , { active : true }) // Greater than db . find ( 'users' , { age : { $gt : 18 } }) // Less than db . find ( 'users' , { age : { $lt : 65 } }) // Greater or equal db . find ( 'users' , { age : { $gte : 18 } }) // Less or equal db . find ( 'users' , { age : { $lte : 65 } }) // Not equal db . find ( 'users' , { status : { $ne : 'inactive' } }) String // Starts with db . find ( 'users' , { name : { $startsWith : 'Al' } }) // Ends with db . find ( 'users' , { email : { $endsWith : '@example.com' } }) // Contains db . find ( 'users' , { bio : { $contains : 'developer' } }) // Regex db . find ( 'users' , { email : { $regex : /@example\\.com$/ } }) Array // In array db . find ( 'users' , { role : { $in : [ 'admin' , 'moderator' ] } }) // Not in array db . find ( 'users' , { status : { $nin : [ 'banned' , 'inactive' ] } }) // Contains value db . find ( 'posts' , { tags : { $contains : 'javascript' } }) Logical // AND (implicit) db . find ( 'users' , { active : true , role : 'admin' }) // OR db . find ( 'users' , { $or : [ { role : 'admin' }, { role : 'moderator' } ]}) // NOT db . find ( 'users' , { status : { $not : 'inactive' } }) Options Pagination const page = 2 ; const limit = 20 ; const offset = ( page - 1 ) * limit ; const users = await db . find ( 'users' , {}, { limit , offset }); Sorting const users = await db . find ( 'users' , {}, { sort : { createdAt : - 1 } // -1 = desc, 1 = asc }); Selection const users = await db . find ( 'users' , {}, { select : [ 'id' , 'name' , 'email' ] // Only these fields }); Full Example const users = await db . find ( 'users' , { active : true , age : { $gte : 18 } }, { select : [ 'id' , 'name' , 'email' ], sort : { createdAt : - 1 }, limit : 10 , offset : 20 } ); Data Types Supported types by database: SQLite INTEGER (int) TEXT (string) REAL (float) BLOB (buffer) NULL PostgreSQL INTEGER VARCHAR, TEXT NUMERIC, DECIMAL BOOLEAN TIMESTAMP UUID JSONB MySQL INT VARCHAR, TEXT DECIMAL BOOLEAN DATETIME JSON MongoDB String Number Boolean Date ObjectId Array Object Error Handling try { const user = await db . findOne ( 'users' , { id : 999 }); if ( ! user ) { throw new Error ( 'User not found' ); } } catch ( err ) { console . error ( 'Database error:' , err ); // Handle error } Connection Pooling const config = { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL , pool : { min : 2 , max : 10 } } }; const db = new DB ( config ); Migrations Create migration files: // migrations/001_create_users.ts export async function up ( db : DB ) { await db . exec ( ` CREATE TABLE users ( id INTEGER PRIMARY KEY, name VARCHAR(255), email VARCHAR(255) UNIQUE ) ` ); } export async function down ( db : DB ) { await db . exec ( 'DROP TABLE users' ); } Views Create database views: await db . exec ( ` CREATE VIEW active_users AS SELECT * FROM users WHERE active = true ` ); const activeUsers = await db . find ( 'active_users' , {}); Indexes Create indexes for performance: await db . exec ( 'CREATE INDEX idx_email ON users(email)' ); await db . exec ( 'CREATE INDEX idx_created ON posts(created_at DESC)' ); Transactions ACID transactions: await db . transaction ( async ( tx ) => { const user = await tx . insert ( 'users' , { name : 'Alice' }); const profile = await tx . insert ( 'profiles' , { userId : user.id , bio : 'New user' }); return { user , profile }; }); Rollback on error: try { await db . transaction ( async ( tx ) => { await tx . update ( 'users' , { id : 1 }, { balance : 50 }); // This error triggers rollback throw new Error ( 'Insufficient funds' ); await tx . update ( 'accounts' , { id : 1 }, { balance : 150 }); }); } catch ( err ) { // Both operations rolled back } Raw Queries const result = await db . query ( 'SELECT * FROM users WHERE id = ?' , [ 123 ] ); // Parameterized to prevent SQL injection","title":"DB API"},{"location":"api/database/#db-class","text":"import { DB } from '@src/db' ; const db = new DB ({ type : 'sqlite' }); await db . connect ();","title":"DB Class"},{"location":"api/database/#methods","text":"","title":"Methods"},{"location":"api/database/#connect","text":"Initialize database connection: const db = new DB ( config ); await db . connect ();","title":"connect()"},{"location":"api/database/#disconnect","text":"Close connection: await db . disconnect ();","title":"disconnect()"},{"location":"api/database/#insert","text":"Add new record: const result = await db . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); // Returns { id: 1, ... }","title":"insert()"},{"location":"api/database/#find","text":"Query multiple records: const users = await db . find ( 'users' , { active : true }); const results = await db . find ( 'users' , { name : { $startsWith : 'A' } });","title":"find()"},{"location":"api/database/#findone","text":"Get single record: const user = await db . findOne ( 'users' , { id : 1 }); // Returns user object or null","title":"findOne()"},{"location":"api/database/#update","text":"Modify records: await db . update ( 'users' , { id : 1 }, // Filter { name : 'Bob' , active : true } // Updates );","title":"update()"},{"location":"api/database/#delete","text":"Remove records: await db . delete ( 'users' , { id : 1 });","title":"delete()"},{"location":"api/database/#count","text":"Count records: const total = await db . count ( 'users' , {}); const active = await db . count ( 'users' , { active : true });","title":"count()"},{"location":"api/database/#exec","text":"Execute raw SQL: await db . exec ( ` CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL ) ` );","title":"exec()"},{"location":"api/database/#transaction","text":"Atomic operations: await db . transaction ( async ( tx ) => { await tx . insert ( 'users' , { name : 'Alice' }); await tx . insert ( 'profiles' , { userId : 1 }); }); All changes committed or rolled back together.","title":"transaction()"},{"location":"api/database/#query-operators","text":"","title":"Query Operators"},{"location":"api/database/#comparison","text":"// Equals db . find ( 'users' , { active : true }) // Greater than db . find ( 'users' , { age : { $gt : 18 } }) // Less than db . find ( 'users' , { age : { $lt : 65 } }) // Greater or equal db . find ( 'users' , { age : { $gte : 18 } }) // Less or equal db . find ( 'users' , { age : { $lte : 65 } }) // Not equal db . find ( 'users' , { status : { $ne : 'inactive' } })","title":"Comparison"},{"location":"api/database/#string","text":"// Starts with db . find ( 'users' , { name : { $startsWith : 'Al' } }) // Ends with db . find ( 'users' , { email : { $endsWith : '@example.com' } }) // Contains db . find ( 'users' , { bio : { $contains : 'developer' } }) // Regex db . find ( 'users' , { email : { $regex : /@example\\.com$/ } })","title":"String"},{"location":"api/database/#array","text":"// In array db . find ( 'users' , { role : { $in : [ 'admin' , 'moderator' ] } }) // Not in array db . find ( 'users' , { status : { $nin : [ 'banned' , 'inactive' ] } }) // Contains value db . find ( 'posts' , { tags : { $contains : 'javascript' } })","title":"Array"},{"location":"api/database/#logical","text":"// AND (implicit) db . find ( 'users' , { active : true , role : 'admin' }) // OR db . find ( 'users' , { $or : [ { role : 'admin' }, { role : 'moderator' } ]}) // NOT db . find ( 'users' , { status : { $not : 'inactive' } })","title":"Logical"},{"location":"api/database/#options","text":"","title":"Options"},{"location":"api/database/#pagination","text":"const page = 2 ; const limit = 20 ; const offset = ( page - 1 ) * limit ; const users = await db . find ( 'users' , {}, { limit , offset });","title":"Pagination"},{"location":"api/database/#sorting","text":"const users = await db . find ( 'users' , {}, { sort : { createdAt : - 1 } // -1 = desc, 1 = asc });","title":"Sorting"},{"location":"api/database/#selection","text":"const users = await db . find ( 'users' , {}, { select : [ 'id' , 'name' , 'email' ] // Only these fields });","title":"Selection"},{"location":"api/database/#full-example","text":"const users = await db . find ( 'users' , { active : true , age : { $gte : 18 } }, { select : [ 'id' , 'name' , 'email' ], sort : { createdAt : - 1 }, limit : 10 , offset : 20 } );","title":"Full Example"},{"location":"api/database/#data-types","text":"Supported types by database:","title":"Data Types"},{"location":"api/database/#sqlite","text":"INTEGER (int) TEXT (string) REAL (float) BLOB (buffer) NULL","title":"SQLite"},{"location":"api/database/#postgresql","text":"INTEGER VARCHAR, TEXT NUMERIC, DECIMAL BOOLEAN TIMESTAMP UUID JSONB","title":"PostgreSQL"},{"location":"api/database/#mysql","text":"INT VARCHAR, TEXT DECIMAL BOOLEAN DATETIME JSON","title":"MySQL"},{"location":"api/database/#mongodb","text":"String Number Boolean Date ObjectId Array Object","title":"MongoDB"},{"location":"api/database/#error-handling","text":"try { const user = await db . findOne ( 'users' , { id : 999 }); if ( ! user ) { throw new Error ( 'User not found' ); } } catch ( err ) { console . error ( 'Database error:' , err ); // Handle error }","title":"Error Handling"},{"location":"api/database/#connection-pooling","text":"const config = { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL , pool : { min : 2 , max : 10 } } }; const db = new DB ( config );","title":"Connection Pooling"},{"location":"api/database/#migrations","text":"Create migration files: // migrations/001_create_users.ts export async function up ( db : DB ) { await db . exec ( ` CREATE TABLE users ( id INTEGER PRIMARY KEY, name VARCHAR(255), email VARCHAR(255) UNIQUE ) ` ); } export async function down ( db : DB ) { await db . exec ( 'DROP TABLE users' ); }","title":"Migrations"},{"location":"api/database/#views","text":"Create database views: await db . exec ( ` CREATE VIEW active_users AS SELECT * FROM users WHERE active = true ` ); const activeUsers = await db . find ( 'active_users' , {});","title":"Views"},{"location":"api/database/#indexes","text":"Create indexes for performance: await db . exec ( 'CREATE INDEX idx_email ON users(email)' ); await db . exec ( 'CREATE INDEX idx_created ON posts(created_at DESC)' );","title":"Indexes"},{"location":"api/database/#transactions","text":"ACID transactions: await db . transaction ( async ( tx ) => { const user = await tx . insert ( 'users' , { name : 'Alice' }); const profile = await tx . insert ( 'profiles' , { userId : user.id , bio : 'New user' }); return { user , profile }; }); Rollback on error: try { await db . transaction ( async ( tx ) => { await tx . update ( 'users' , { id : 1 }, { balance : 50 }); // This error triggers rollback throw new Error ( 'Insufficient funds' ); await tx . update ( 'accounts' , { id : 1 }, { balance : 150 }); }); } catch ( err ) { // Both operations rolled back }","title":"Transactions"},{"location":"api/database/#raw-queries","text":"const result = await db . query ( 'SELECT * FROM users WHERE id = ?' , [ 123 ] ); // Parameterized to prevent SQL injection","title":"Raw Queries"},{"location":"api/routing/","text":"Complete API reference for routing in Jen.js. Types LoaderContext Data passed to loader functions: interface LoaderContext { params : Record < string , string | string [] > ; request : IncomingMessage ; response : ServerResponse ; query : URLSearchParams ; } Route Internal route representation: interface Route { path : string ; // /posts/:id file : string ; // site/posts/($id).tsx component : ( props : any ) => JSX . Element ; loader ?: ( ctx : LoaderContext ) => Promise < any > ; head ?: ( props : any ) => JSX . Element ; staticPaths ?: () => Promise < StaticPath [] > ; mode ?: 'ssr' | 'ssg' ; revalidate? : number ; } Loader Functions Export async function to load data: export async function loader ( ctx : LoaderContext ) { return { title : 'Page Title' , data : await fetchData () }; } export default function Page ({ data } : any ) { return < h1 > { data . title } < /h1>; } Access Parameters export async function loader ( ctx : LoaderContext ) { const id = ctx . params . id ; // Route parameter const page = ctx . query . get ( 'page' ); // Query parameter const token = ctx . request . headers . authorization ; return { /* ... */ }; } Access Request/Response export async function loader ( ctx : LoaderContext ) { const method = ctx . request . method ; const url = ctx . request . url ; const headers = ctx . request . headers ; // Set response headers ctx . response . setHeader ( 'Cache-Control' , 'max-age=3600' ); return { /* ... */ }; } Head Function Custom head elements per page: export function Head ({ data } : any ) { return ( <> < title > { data . title } < /title> < meta name = \"description\" content = { data . description } /> < meta property = \"og:title\" content = { data . title } /> < meta property = \"og:image\" content = { data . image } /> < link rel = \"canonical\" href = { `https://example.com ${ data . path } ` } /> < /> ); } Static Paths Precompute paths for dynamic routes (SSG): export async function staticPaths () { const posts = await getAllPosts (); return posts . map ( post => ({ slug : post.slug , category : post.category })); } export async function loader ( ctx : LoaderContext ) { const post = await getPost ( ctx . params . slug ); return { post }; } Generates routes for all returned paths. Route Matching Static Routes Exact path matching: site/(about).tsx \u2192 /about (only) Dynamic Routes Parameter matching: site/posts/($id).tsx \u2192 /posts/* (any id) site/users/($userId)/posts/($postId).tsx \u2192 /users/*/posts/* Parameters captured as ctx.params.id , ctx.params.userId , etc. Catch-All Routes Matches remaining segments: site/(...rest).tsx \u2192 /* (any path) site/docs/(...path).tsx \u2192 /docs/* (under /docs) Access remaining segments: export async function loader ( ctx : LoaderContext ) { const segments = ctx . params . rest ; // Array of segments const path = segments . join ( '/' ); return { path }; } Query Parameters Access URL query string: export async function loader ( ctx : LoaderContext ) { const page = ctx . query . get ( 'page' ); const search = ctx . query . get ( 'search' ); const filters = ctx . query . getAll ( 'filter' ); return { page , search , filters }; } Route Configuration Override defaults per route: // Rendering mode export const mode = 'ssr' | 'ssg' ; // Revalidation time (seconds) export const revalidate = 3600 ; // Route metadata export const meta = { title : 'Page Title' , description : 'Page description' }; // Middleware export const middleware = [ authMiddleware ]; Error Handling export async function loader ( ctx : LoaderContext ) { try { const data = await fetchData (); return { data }; } catch ( err ) { // Return error page ctx . response . writeHead ( 500 ); ctx . response . end ( 'Server error' ); return {}; } } Redirects export async function loader ( ctx : LoaderContext ) { if ( ! isAuthenticated ( ctx )) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } return { /* ... */ }; } Middleware in Routes Apply middleware to specific routes: import { authMiddleware } from '@src/middleware/auth' ; export const middleware = [ authMiddleware ]; export async function loader ( ctx : LoaderContext ) { // User is authenticated const userId = ctx . request . user ? . id ; return { userId }; } Component Props interface PageProps { data? : any ; // From loader params? : Record < string , any > ; // Route params query? : URLSearchParams ; // Query string } export default function Page ({ data , params , query } : PageProps ) { return < h1 > { data ? . title } < /h1>; } API Routes Exports handle function instead of default: import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 ); res . end ( 'GET response' ); } } Query Parameters in API Routes export async function handle ( req : IncomingMessage , res : ServerResponse ) { const url = new URL ( req . url ! , `http:// ${ req . headers . host } ` ); const page = url . searchParams . get ( 'page' ); const limit = url . searchParams . get ( 'limit' ); // Use page, limit } Route Order Routes matched by specificity: Exact matches ( /about before ($slug) ) Specific dynamic routes before catch-alls More nested routes before less nested File Extensions Supported route file extensions: .tsx \u2014 Page component .jsx \u2014 Page component (not recommended) .ts \u2014 API route .js \u2014 API route (not recommended) Naming Conventions Good route names: (home).tsx \u2014 Homepage (blog).tsx \u2014 Blog index ($slug).tsx \u2014 Dynamic route (...rest).tsx \u2014 Catch-all (...rest) \u2014 Avoid dots, use hyphens Bad route names: home.tsx \u2014 Missing parentheses (home page).tsx \u2014 Space in name (.tsx \u2014 Syntax error home-page.tsx \u2014 Missing parentheses","title":"Routing API"},{"location":"api/routing/#types","text":"","title":"Types"},{"location":"api/routing/#loadercontext","text":"Data passed to loader functions: interface LoaderContext { params : Record < string , string | string [] > ; request : IncomingMessage ; response : ServerResponse ; query : URLSearchParams ; }","title":"LoaderContext"},{"location":"api/routing/#route","text":"Internal route representation: interface Route { path : string ; // /posts/:id file : string ; // site/posts/($id).tsx component : ( props : any ) => JSX . Element ; loader ?: ( ctx : LoaderContext ) => Promise < any > ; head ?: ( props : any ) => JSX . Element ; staticPaths ?: () => Promise < StaticPath [] > ; mode ?: 'ssr' | 'ssg' ; revalidate? : number ; }","title":"Route"},{"location":"api/routing/#loader-functions","text":"Export async function to load data: export async function loader ( ctx : LoaderContext ) { return { title : 'Page Title' , data : await fetchData () }; } export default function Page ({ data } : any ) { return < h1 > { data . title } < /h1>; }","title":"Loader Functions"},{"location":"api/routing/#access-parameters","text":"export async function loader ( ctx : LoaderContext ) { const id = ctx . params . id ; // Route parameter const page = ctx . query . get ( 'page' ); // Query parameter const token = ctx . request . headers . authorization ; return { /* ... */ }; }","title":"Access Parameters"},{"location":"api/routing/#access-requestresponse","text":"export async function loader ( ctx : LoaderContext ) { const method = ctx . request . method ; const url = ctx . request . url ; const headers = ctx . request . headers ; // Set response headers ctx . response . setHeader ( 'Cache-Control' , 'max-age=3600' ); return { /* ... */ }; }","title":"Access Request/Response"},{"location":"api/routing/#head-function","text":"Custom head elements per page: export function Head ({ data } : any ) { return ( <> < title > { data . title } < /title> < meta name = \"description\" content = { data . description } /> < meta property = \"og:title\" content = { data . title } /> < meta property = \"og:image\" content = { data . image } /> < link rel = \"canonical\" href = { `https://example.com ${ data . path } ` } /> < /> ); }","title":"Head Function"},{"location":"api/routing/#static-paths","text":"Precompute paths for dynamic routes (SSG): export async function staticPaths () { const posts = await getAllPosts (); return posts . map ( post => ({ slug : post.slug , category : post.category })); } export async function loader ( ctx : LoaderContext ) { const post = await getPost ( ctx . params . slug ); return { post }; } Generates routes for all returned paths.","title":"Static Paths"},{"location":"api/routing/#route-matching","text":"","title":"Route Matching"},{"location":"api/routing/#static-routes","text":"Exact path matching: site/(about).tsx \u2192 /about (only)","title":"Static Routes"},{"location":"api/routing/#dynamic-routes","text":"Parameter matching: site/posts/($id).tsx \u2192 /posts/* (any id) site/users/($userId)/posts/($postId).tsx \u2192 /users/*/posts/* Parameters captured as ctx.params.id , ctx.params.userId , etc.","title":"Dynamic Routes"},{"location":"api/routing/#catch-all-routes","text":"Matches remaining segments: site/(...rest).tsx \u2192 /* (any path) site/docs/(...path).tsx \u2192 /docs/* (under /docs) Access remaining segments: export async function loader ( ctx : LoaderContext ) { const segments = ctx . params . rest ; // Array of segments const path = segments . join ( '/' ); return { path }; }","title":"Catch-All Routes"},{"location":"api/routing/#query-parameters","text":"Access URL query string: export async function loader ( ctx : LoaderContext ) { const page = ctx . query . get ( 'page' ); const search = ctx . query . get ( 'search' ); const filters = ctx . query . getAll ( 'filter' ); return { page , search , filters }; }","title":"Query Parameters"},{"location":"api/routing/#route-configuration","text":"Override defaults per route: // Rendering mode export const mode = 'ssr' | 'ssg' ; // Revalidation time (seconds) export const revalidate = 3600 ; // Route metadata export const meta = { title : 'Page Title' , description : 'Page description' }; // Middleware export const middleware = [ authMiddleware ];","title":"Route Configuration"},{"location":"api/routing/#error-handling","text":"export async function loader ( ctx : LoaderContext ) { try { const data = await fetchData (); return { data }; } catch ( err ) { // Return error page ctx . response . writeHead ( 500 ); ctx . response . end ( 'Server error' ); return {}; } }","title":"Error Handling"},{"location":"api/routing/#redirects","text":"export async function loader ( ctx : LoaderContext ) { if ( ! isAuthenticated ( ctx )) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } return { /* ... */ }; }","title":"Redirects"},{"location":"api/routing/#middleware-in-routes","text":"Apply middleware to specific routes: import { authMiddleware } from '@src/middleware/auth' ; export const middleware = [ authMiddleware ]; export async function loader ( ctx : LoaderContext ) { // User is authenticated const userId = ctx . request . user ? . id ; return { userId }; }","title":"Middleware in Routes"},{"location":"api/routing/#component-props","text":"interface PageProps { data? : any ; // From loader params? : Record < string , any > ; // Route params query? : URLSearchParams ; // Query string } export default function Page ({ data , params , query } : PageProps ) { return < h1 > { data ? . title } < /h1>; }","title":"Component Props"},{"location":"api/routing/#api-routes","text":"Exports handle function instead of default: import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 ); res . end ( 'GET response' ); } }","title":"API Routes"},{"location":"api/routing/#query-parameters-in-api-routes","text":"export async function handle ( req : IncomingMessage , res : ServerResponse ) { const url = new URL ( req . url ! , `http:// ${ req . headers . host } ` ); const page = url . searchParams . get ( 'page' ); const limit = url . searchParams . get ( 'limit' ); // Use page, limit }","title":"Query Parameters in API Routes"},{"location":"api/routing/#route-order","text":"Routes matched by specificity: Exact matches ( /about before ($slug) ) Specific dynamic routes before catch-alls More nested routes before less nested","title":"Route Order"},{"location":"api/routing/#file-extensions","text":"Supported route file extensions: .tsx \u2014 Page component .jsx \u2014 Page component (not recommended) .ts \u2014 API route .js \u2014 API route (not recommended)","title":"File Extensions"},{"location":"api/routing/#naming-conventions","text":"Good route names: (home).tsx \u2014 Homepage (blog).tsx \u2014 Blog index ($slug).tsx \u2014 Dynamic route (...rest).tsx \u2014 Catch-all (...rest) \u2014 Avoid dots, use hyphens Bad route names: home.tsx \u2014 Missing parentheses (home page).tsx \u2014 Space in name (.tsx \u2014 Syntax error home-page.tsx \u2014 Missing parentheses","title":"Naming Conventions"},{"location":"core/configuration/","text":"Customize Jen.js behavior with jen.config.ts in your project root. Basic Configuration jen.config.ts import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , rendering : { defaultMode : 'ssr' , defaultRevalidateSeconds : 60 }, routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true } }; export default config ; Configuration Options Directories { // Source directory containing site routes siteDir : 'site' , // Output directory for built files distDir : 'dist' , // Public assets directory (copied as-is) publicDir : 'public' , // Cache directory cacheDir : '.jen-cache' } Rendering { rendering : { // 'ssr' = Server-Side Rendering (dynamic per request) // 'ssg' = Static Site Generation (pre-built HTML) defaultMode : 'ssr' , // How often to revalidate static pages (seconds) defaultRevalidateSeconds : 60 , // Whether to hydrate client-side in SSG hydrate : true , // CSS-in-JS framework (if any) cssFramework : 'none' // or 'emotion', 'styled-components' } } Routing { routes : { // File extensions to scan for routes fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], // Regex pattern for route files: (name).tsx routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , // Allow index routes like (index).tsx \u2192 / enableIndexFallback : true , // Case-sensitive routing caseSensitive : false } } Build { build : { // Minify output minify : true , // Source maps in production sourceMaps : false , // Code splitting strategy splitting : 'auto' , // 'auto', 'manual', 'none' // External dependencies (don't bundle) external : [ 'express' , 'pg' ], // Environment variables to inline define : { __VERSION__ : '\"1.0.0\"' } } } Server { server : { // Host and port host : '0.0.0.0' , port : 3000 , // CORS configuration cors : { origin : '*' , credentials : true }, // Request timeout (ms) timeout : 30000 , // Body size limit bodySizeLimit : '10mb' } } Database { database : { // Primary database configuration default : { type : 'sqlite' , config : { filename : './data.db' } }, // Additional databases connections : { cache : { type : 'redis' , config : { url : 'redis://localhost:6379' } }, search : { type : 'mongodb' , config : { url : 'mongodb://localhost:27017/app' } } } } } Plugins { plugins : [ // Load plugins '@jen/plugin-analytics' , './src/plugins/custom-plugin.ts' ] } Middleware { middleware : [ // Global middleware 'cors' , 'compression' , './src/middleware/auth.ts' ] } TypeScript { typescript : { // Check types during build typeCheck : true , // Strict mode strict : true , // ES target target : 'ES2022' } } Environment Variables Load from .env file: # .env DATABASE_URL = sqlite://./data.db REDIS_URL = redis://localhost:6379 API_KEY = secret123 NODE_ENV = development Access in config or code: const config : FrameworkConfig = { server : { port : parseInt ( process . env . PORT || '3000' ) }, build : { define : { __API_URL__ : JSON.stringify ( process . env . API_URL ) } } }; Different Configs Per Environment Create separate config files: jen.config.ts # Development jen.config.production.ts # Production jen.config.test.ts # Testing Or use environment variables: import type { FrameworkConfig } from '@src/core/config' ; const isDev = process . env . NODE_ENV === 'development' ; const isProd = process . env . NODE_ENV === 'production' ; const config : FrameworkConfig = { rendering : { defaultMode : isProd ? 'ssg' : 'ssr' }, build : { minify : isProd , sourceMaps : isDev }, server : { port : isDev ? 3000 : 8080 } }; export default config ; Common Configurations Static Site (Blog) const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , rendering : { defaultMode : 'ssg' , // Pre-build all pages defaultRevalidateSeconds : 3600 }, build : { minify : true , sourceMaps : false } }; Server-Side Rendering const config : FrameworkConfig = { rendering : { defaultMode : 'ssr' // Render on request }, server : { port : 3000 , timeout : 30000 } }; API Server const config : FrameworkConfig = { siteDir : 'api' , // Only API routes rendering : { defaultMode : 'ssr' }, server : { cors : { origin : [ 'https://myapp.com' ], credentials : true } } }; Hybrid (SSG + SSR) const config : FrameworkConfig = { rendering : { defaultMode : 'ssg' // Most pages static }, routes : { // Specific routes can override with frontmatter: // export const mode = 'ssr'; } }; Per-Route Configuration Override config in individual route files: // site/(home).tsx // This route always uses SSR export const mode = 'ssr' ; // Cache for 1 hour export const revalidate = 3600 ; // Custom metadata export const meta = { title : 'Home' , description : 'Welcome' }; export default function Home () { // ... } TypeScript Configuration Configure TypeScript in tsconfig.json : { \"compilerOptions\" : { \"target\" : \"ES2022\" , \"module\" : \"ES2020\" , \"lib\" : [ \"ES2022\" ], \"jsx\" : \"react-jsx\" , \"jsxImportSource\" : \"preact\" , \"strict\" : true , \"moduleResolution\" : \"bundler\" , \"baseUrl\" : \".\" , \"paths\" : { \"@src/*\" : [ \"src/*\" ] } }, \"include\" : [ \"src\" , \"site\" ] } Validation Configuration is validated at startup. Invalid options cause errors: Error: Unknown configuration key \"invalidKey\" Check your jen.config.ts for typos or unsupported options. Next Steps Configure your database Set up environment variables Customize build settings Add plugins","title":"Configuration"},{"location":"core/configuration/#basic-configuration","text":"jen.config.ts import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , rendering : { defaultMode : 'ssr' , defaultRevalidateSeconds : 60 }, routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true } }; export default config ;","title":"Basic Configuration"},{"location":"core/configuration/#configuration-options","text":"","title":"Configuration Options"},{"location":"core/configuration/#directories","text":"{ // Source directory containing site routes siteDir : 'site' , // Output directory for built files distDir : 'dist' , // Public assets directory (copied as-is) publicDir : 'public' , // Cache directory cacheDir : '.jen-cache' }","title":"Directories"},{"location":"core/configuration/#rendering","text":"{ rendering : { // 'ssr' = Server-Side Rendering (dynamic per request) // 'ssg' = Static Site Generation (pre-built HTML) defaultMode : 'ssr' , // How often to revalidate static pages (seconds) defaultRevalidateSeconds : 60 , // Whether to hydrate client-side in SSG hydrate : true , // CSS-in-JS framework (if any) cssFramework : 'none' // or 'emotion', 'styled-components' } }","title":"Rendering"},{"location":"core/configuration/#routing","text":"{ routes : { // File extensions to scan for routes fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], // Regex pattern for route files: (name).tsx routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , // Allow index routes like (index).tsx \u2192 / enableIndexFallback : true , // Case-sensitive routing caseSensitive : false } }","title":"Routing"},{"location":"core/configuration/#build","text":"{ build : { // Minify output minify : true , // Source maps in production sourceMaps : false , // Code splitting strategy splitting : 'auto' , // 'auto', 'manual', 'none' // External dependencies (don't bundle) external : [ 'express' , 'pg' ], // Environment variables to inline define : { __VERSION__ : '\"1.0.0\"' } } }","title":"Build"},{"location":"core/configuration/#server","text":"{ server : { // Host and port host : '0.0.0.0' , port : 3000 , // CORS configuration cors : { origin : '*' , credentials : true }, // Request timeout (ms) timeout : 30000 , // Body size limit bodySizeLimit : '10mb' } }","title":"Server"},{"location":"core/configuration/#database","text":"{ database : { // Primary database configuration default : { type : 'sqlite' , config : { filename : './data.db' } }, // Additional databases connections : { cache : { type : 'redis' , config : { url : 'redis://localhost:6379' } }, search : { type : 'mongodb' , config : { url : 'mongodb://localhost:27017/app' } } } } }","title":"Database"},{"location":"core/configuration/#plugins","text":"{ plugins : [ // Load plugins '@jen/plugin-analytics' , './src/plugins/custom-plugin.ts' ] }","title":"Plugins"},{"location":"core/configuration/#middleware","text":"{ middleware : [ // Global middleware 'cors' , 'compression' , './src/middleware/auth.ts' ] }","title":"Middleware"},{"location":"core/configuration/#typescript","text":"{ typescript : { // Check types during build typeCheck : true , // Strict mode strict : true , // ES target target : 'ES2022' } }","title":"TypeScript"},{"location":"core/configuration/#environment-variables","text":"Load from .env file: # .env DATABASE_URL = sqlite://./data.db REDIS_URL = redis://localhost:6379 API_KEY = secret123 NODE_ENV = development Access in config or code: const config : FrameworkConfig = { server : { port : parseInt ( process . env . PORT || '3000' ) }, build : { define : { __API_URL__ : JSON.stringify ( process . env . API_URL ) } } };","title":"Environment Variables"},{"location":"core/configuration/#different-configs-per-environment","text":"Create separate config files: jen.config.ts # Development jen.config.production.ts # Production jen.config.test.ts # Testing Or use environment variables: import type { FrameworkConfig } from '@src/core/config' ; const isDev = process . env . NODE_ENV === 'development' ; const isProd = process . env . NODE_ENV === 'production' ; const config : FrameworkConfig = { rendering : { defaultMode : isProd ? 'ssg' : 'ssr' }, build : { minify : isProd , sourceMaps : isDev }, server : { port : isDev ? 3000 : 8080 } }; export default config ;","title":"Different Configs Per Environment"},{"location":"core/configuration/#common-configurations","text":"","title":"Common Configurations"},{"location":"core/configuration/#static-site-blog","text":"const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , rendering : { defaultMode : 'ssg' , // Pre-build all pages defaultRevalidateSeconds : 3600 }, build : { minify : true , sourceMaps : false } };","title":"Static Site (Blog)"},{"location":"core/configuration/#server-side-rendering","text":"const config : FrameworkConfig = { rendering : { defaultMode : 'ssr' // Render on request }, server : { port : 3000 , timeout : 30000 } };","title":"Server-Side Rendering"},{"location":"core/configuration/#api-server","text":"const config : FrameworkConfig = { siteDir : 'api' , // Only API routes rendering : { defaultMode : 'ssr' }, server : { cors : { origin : [ 'https://myapp.com' ], credentials : true } } };","title":"API Server"},{"location":"core/configuration/#hybrid-ssg-ssr","text":"const config : FrameworkConfig = { rendering : { defaultMode : 'ssg' // Most pages static }, routes : { // Specific routes can override with frontmatter: // export const mode = 'ssr'; } };","title":"Hybrid (SSG + SSR)"},{"location":"core/configuration/#per-route-configuration","text":"Override config in individual route files: // site/(home).tsx // This route always uses SSR export const mode = 'ssr' ; // Cache for 1 hour export const revalidate = 3600 ; // Custom metadata export const meta = { title : 'Home' , description : 'Welcome' }; export default function Home () { // ... }","title":"Per-Route Configuration"},{"location":"core/configuration/#typescript-configuration","text":"Configure TypeScript in tsconfig.json : { \"compilerOptions\" : { \"target\" : \"ES2022\" , \"module\" : \"ES2020\" , \"lib\" : [ \"ES2022\" ], \"jsx\" : \"react-jsx\" , \"jsxImportSource\" : \"preact\" , \"strict\" : true , \"moduleResolution\" : \"bundler\" , \"baseUrl\" : \".\" , \"paths\" : { \"@src/*\" : [ \"src/*\" ] } }, \"include\" : [ \"src\" , \"site\" ] }","title":"TypeScript Configuration"},{"location":"core/configuration/#validation","text":"Configuration is validated at startup. Invalid options cause errors: Error: Unknown configuration key \"invalidKey\" Check your jen.config.ts for typos or unsupported options.","title":"Validation"},{"location":"core/configuration/#next-steps","text":"Configure your database Set up environment variables Customize build settings Add plugins","title":"Next Steps"},{"location":"core/routing/","text":"Jen.js uses file-based routing \u2014 your file structure automatically becomes your routes. No configuration needed. Basic Concept Files in site/ are converted to routes: File Route Type (home).tsx / Page (about).tsx /about Page contact/(form).tsx /contact/form Page api/(users).ts /api/users API Route File Naming Route files follow the pattern: (name).tsx or (name).ts Valid names: - (home).tsx \u2014 alphanumeric, hyphens, underscores - (user-profile).tsx \u2014 hyphens are allowed - (api_users).ts \u2014 underscores are allowed Invalid names: - home.tsx \u2014 missing parentheses - (home).test.tsx \u2014 test files ignored - home.module.tsx \u2014 module files ignored Static Routes Create a file to create a static route: site/(about).tsx export default function About () { return < h1 > About Page < /h1>; } Access at /about Nested Routes Nested directories create nested routes: site/ \u251c\u2500\u2500 (home).tsx \u2192 / \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 (index).tsx \u2192 /blog \u2502 \u2514\u2500\u2500 (post).tsx \u2192 /blog/post \u2514\u2500\u2500 docs/ \u251c\u2500\u2500 (intro).tsx \u2192 /docs/intro \u2514\u2500\u2500 api/ \u2514\u2500\u2500 (reference).tsx \u2192 /docs/api/reference Dynamic Routes Use $ prefix for dynamic segments: site/posts/($id).tsx import type { LoaderContext } from '@src/core/routes' ; export async function loader ( ctx : LoaderContext ) { const postId = ctx . params . id ; // Fetch post by ID const post = await getPost ( postId ); return post ; } export default function Post ({ data } : any ) { return ( < article > < h1 > { data . title } < /h1> < p > { data . content } < /p> < /article> ); } Access with: /posts/1 , /posts/hello , /posts/any-value Multiple Dynamic Segments site/users/($userId)/posts/($postId).tsx export async function loader ( ctx : LoaderContext ) { const userId = ctx . params . userId ; const postId = ctx . params . postId ; // ... } Access with: /users/john/posts/42 Catch-All Routes Use (...name) for catch-all routes: site/docs/(...rest).tsx export async function loader ( ctx : LoaderContext ) { const pathSegments = ctx . params . rest ; // array of segments // Handle any path under /docs/* } Access with: - /docs/intro - /docs/api/reference - /docs/api/reference/functions Route Exports Default Export (Required) The default export is your page component: export default function MyPage () { return < h1 > Hello < /h1>; } Loader Export (Optional) Load data before rendering: export async function loader ( ctx : LoaderContext ) { return { title : 'My Page' , items : await fetchItems () }; } Data passed to component: export default function MyPage ({ data } : { data : any }) { return < h1 > { data . title } < /h1>; } Head Export (Optional) Custom head elements: export function Head ({ data } : any ) { return ( <> < title > { data . title } < /title> < meta name = \"description\" content = { data . description } /> < meta property = \"og:title\" content = { data . title } /> < /> ); } API Routes API routes handle HTTP requests without rendering HTML: site/api/(users).ts import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [] })); } else if ( req . method === 'POST' ) { // Handle POST } else { res . writeHead ( 405 ); res . end ( 'Method Not Allowed' ); } } Reading Request Body export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => { body += chunk . toString (); }); req . on ( 'end' , () => { const data = JSON . parse ( body ); // Process data res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true })); }); } } Query Parameters export async function handle ( req : IncomingMessage , res : ServerResponse ) { const url = new URL ( req . url ! , `http:// ${ req . headers . host } ` ); const search = url . searchParams . get ( 'search' ); // Use search parameter } Route Context The LoaderContext provides: interface LoaderContext { params : Record < string , string | string [] > ; // Route parameters request : IncomingMessage ; // HTTP request response : ServerResponse ; // HTTP response query : URLSearchParams ; // Query parameters } Example For route /users/john/posts/42?tab=comments : export async function loader ( ctx : LoaderContext ) { console . log ( ctx . params ); // { userId: 'john', postId: '42' } console . log ( ctx . query . get ( 'tab' )); // 'comments' } Route Ordering Routes are matched in order of specificity: Static routes (e.g., /about ) Dynamic routes (e.g., /posts/:id ) Catch-all routes (e.g., /docs/* ) So /posts/new matches the static route before ($id) route. Special Routes Error Pages Create site/(error).tsx for 404s: export default function NotFound () { return < h1 > Page Not Found < /h1>; } Redirects Use middleware or loader to redirect: export async function loader ( ctx : LoaderContext ) { if ( ! userAuthenticated ) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } // ... } Static vs Dynamic Routes Static Generation For routes that don't change: // site/(about).tsx export default function About () { return < h1 > About < /h1>; } Build with npm run build \u2014 creates static HTML. Dynamic Routes For routes that change per request: // site/posts/($id).tsx export async function loader ( ctx : LoaderContext ) { // This runs on every request (SSR) return { post : await getPost ( ctx . params . id ) }; } Leave running or use SSR mode. Best Practices Use meaningful names: (user-profile) not (up) Keep routes flat unless nesting is logical Use API routes for backend logic Export loaders for data dependencies Use Head export for SEO meta tags","title":"Routing"},{"location":"core/routing/#basic-concept","text":"Files in site/ are converted to routes: File Route Type (home).tsx / Page (about).tsx /about Page contact/(form).tsx /contact/form Page api/(users).ts /api/users API","title":"Basic Concept"},{"location":"core/routing/#route-file-naming","text":"Route files follow the pattern: (name).tsx or (name).ts Valid names: - (home).tsx \u2014 alphanumeric, hyphens, underscores - (user-profile).tsx \u2014 hyphens are allowed - (api_users).ts \u2014 underscores are allowed Invalid names: - home.tsx \u2014 missing parentheses - (home).test.tsx \u2014 test files ignored - home.module.tsx \u2014 module files ignored","title":"Route File Naming"},{"location":"core/routing/#static-routes","text":"Create a file to create a static route: site/(about).tsx export default function About () { return < h1 > About Page < /h1>; } Access at /about","title":"Static Routes"},{"location":"core/routing/#nested-routes","text":"Nested directories create nested routes: site/ \u251c\u2500\u2500 (home).tsx \u2192 / \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 (index).tsx \u2192 /blog \u2502 \u2514\u2500\u2500 (post).tsx \u2192 /blog/post \u2514\u2500\u2500 docs/ \u251c\u2500\u2500 (intro).tsx \u2192 /docs/intro \u2514\u2500\u2500 api/ \u2514\u2500\u2500 (reference).tsx \u2192 /docs/api/reference","title":"Nested Routes"},{"location":"core/routing/#dynamic-routes","text":"Use $ prefix for dynamic segments: site/posts/($id).tsx import type { LoaderContext } from '@src/core/routes' ; export async function loader ( ctx : LoaderContext ) { const postId = ctx . params . id ; // Fetch post by ID const post = await getPost ( postId ); return post ; } export default function Post ({ data } : any ) { return ( < article > < h1 > { data . title } < /h1> < p > { data . content } < /p> < /article> ); } Access with: /posts/1 , /posts/hello , /posts/any-value","title":"Dynamic Routes"},{"location":"core/routing/#multiple-dynamic-segments","text":"site/users/($userId)/posts/($postId).tsx export async function loader ( ctx : LoaderContext ) { const userId = ctx . params . userId ; const postId = ctx . params . postId ; // ... } Access with: /users/john/posts/42","title":"Multiple Dynamic Segments"},{"location":"core/routing/#catch-all-routes","text":"Use (...name) for catch-all routes: site/docs/(...rest).tsx export async function loader ( ctx : LoaderContext ) { const pathSegments = ctx . params . rest ; // array of segments // Handle any path under /docs/* } Access with: - /docs/intro - /docs/api/reference - /docs/api/reference/functions","title":"Catch-All Routes"},{"location":"core/routing/#route-exports","text":"","title":"Route Exports"},{"location":"core/routing/#default-export-required","text":"The default export is your page component: export default function MyPage () { return < h1 > Hello < /h1>; }","title":"Default Export (Required)"},{"location":"core/routing/#loader-export-optional","text":"Load data before rendering: export async function loader ( ctx : LoaderContext ) { return { title : 'My Page' , items : await fetchItems () }; } Data passed to component: export default function MyPage ({ data } : { data : any }) { return < h1 > { data . title } < /h1>; }","title":"Loader Export (Optional)"},{"location":"core/routing/#head-export-optional","text":"Custom head elements: export function Head ({ data } : any ) { return ( <> < title > { data . title } < /title> < meta name = \"description\" content = { data . description } /> < meta property = \"og:title\" content = { data . title } /> < /> ); }","title":"Head Export (Optional)"},{"location":"core/routing/#api-routes","text":"API routes handle HTTP requests without rendering HTML: site/api/(users).ts import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [] })); } else if ( req . method === 'POST' ) { // Handle POST } else { res . writeHead ( 405 ); res . end ( 'Method Not Allowed' ); } }","title":"API Routes"},{"location":"core/routing/#reading-request-body","text":"export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => { body += chunk . toString (); }); req . on ( 'end' , () => { const data = JSON . parse ( body ); // Process data res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true })); }); } }","title":"Reading Request Body"},{"location":"core/routing/#query-parameters","text":"export async function handle ( req : IncomingMessage , res : ServerResponse ) { const url = new URL ( req . url ! , `http:// ${ req . headers . host } ` ); const search = url . searchParams . get ( 'search' ); // Use search parameter }","title":"Query Parameters"},{"location":"core/routing/#route-context","text":"The LoaderContext provides: interface LoaderContext { params : Record < string , string | string [] > ; // Route parameters request : IncomingMessage ; // HTTP request response : ServerResponse ; // HTTP response query : URLSearchParams ; // Query parameters }","title":"Route Context"},{"location":"core/routing/#example","text":"For route /users/john/posts/42?tab=comments : export async function loader ( ctx : LoaderContext ) { console . log ( ctx . params ); // { userId: 'john', postId: '42' } console . log ( ctx . query . get ( 'tab' )); // 'comments' }","title":"Example"},{"location":"core/routing/#route-ordering","text":"Routes are matched in order of specificity: Static routes (e.g., /about ) Dynamic routes (e.g., /posts/:id ) Catch-all routes (e.g., /docs/* ) So /posts/new matches the static route before ($id) route.","title":"Route Ordering"},{"location":"core/routing/#special-routes","text":"","title":"Special Routes"},{"location":"core/routing/#error-pages","text":"Create site/(error).tsx for 404s: export default function NotFound () { return < h1 > Page Not Found < /h1>; }","title":"Error Pages"},{"location":"core/routing/#redirects","text":"Use middleware or loader to redirect: export async function loader ( ctx : LoaderContext ) { if ( ! userAuthenticated ) { ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } // ... }","title":"Redirects"},{"location":"core/routing/#static-vs-dynamic-routes","text":"","title":"Static vs Dynamic Routes"},{"location":"core/routing/#static-generation","text":"For routes that don't change: // site/(about).tsx export default function About () { return < h1 > About < /h1>; } Build with npm run build \u2014 creates static HTML.","title":"Static Generation"},{"location":"core/routing/#dynamic-routes_1","text":"For routes that change per request: // site/posts/($id).tsx export async function loader ( ctx : LoaderContext ) { // This runs on every request (SSR) return { post : await getPost ( ctx . params . id ) }; } Leave running or use SSR mode.","title":"Dynamic Routes"},{"location":"core/routing/#best-practices","text":"Use meaningful names: (user-profile) not (up) Keep routes flat unless nesting is logical Use API routes for backend logic Export loaders for data dependencies Use Head export for SEO meta tags","title":"Best Practices"},{"location":"core/structure/","text":"Jen.js has a clear, conventional project structure. Understand it to build effective applications. Directory Layout jen.js-app/ \u251c\u2500\u2500 site/ # Application routes and pages \u2502 \u251c\u2500\u2500 (home).tsx # Routes in Preact/JSX \u2502 \u251c\u2500\u2500 (about).tsx \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u251c\u2500\u2500 (index).tsx # /posts \u2192 index page \u2502 \u2502 \u2514\u2500\u2500 ($id).tsx # /posts/:id \u2192 dynamic page \u2502 \u2514\u2500\u2500 api/ \u2502 \u251c\u2500\u2500 (users).ts # /api/users \u2192 API endpoint \u2502 \u2514\u2500\u2500 v1/ \u2502 \u2514\u2500\u2500 (data).ts # /api/v1/data \u2192 nested API \u2502 \u251c\u2500\u2500 src/ # Framework and app code \u2502 \u251c\u2500\u2500 components/ # Reusable Preact components \u2502 \u2502 \u251c\u2500\u2500 header.tsx \u2502 \u2502 \u251c\u2500\u2500 footer.tsx \u2502 \u2502 \u2514\u2500\u2500 nav.tsx \u2502 \u251c\u2500\u2500 lib/ # Utility functions \u2502 \u2502 \u251c\u2500\u2500 db.ts # Database helpers \u2502 \u2502 \u251c\u2500\u2500 api.ts # API client \u2502 \u2502 \u2514\u2500\u2500 utils.ts # Utilities \u2502 \u251c\u2500\u2500 middleware/ # Express-style middleware \u2502 \u2502 \u251c\u2500\u2500 auth.ts \u2502 \u2502 \u2514\u2500\u2500 logging.ts \u2502 \u251c\u2500\u2500 plugins/ # Custom plugins \u2502 \u2502 \u2514\u2500\u2500 my-plugin.ts \u2502 \u2514\u2500\u2500 styles/ # Stylesheets \u2502 \u251c\u2500\u2500 globals.css \u2502 \u2514\u2500\u2500 components.css \u2502 \u251c\u2500\u2500 public/ # Static assets (copied as-is) \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u251c\u2500\u2500 robots.txt \u2502 \u2514\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 dist/ # Build output (generated) \u2502 \u251c\u2500\u2500 index/ \u2502 \u2502 \u2514\u2500\u2500 index.html # Rendered pages \u2502 \u251c\u2500\u2500 api/ # API routes (if SSR) \u2502 \u251c\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 styles.css \u2502 \u2514\u2500\u2500 bundle.js \u2502 \u251c\u2500\u2500 .env # Environment variables (not in git) \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 jen.config.ts # Framework configuration \u251c\u2500\u2500 tsconfig.json # TypeScript configuration \u251c\u2500\u2500 package.json # Dependencies and scripts \u2514\u2500\u2500 README.md Key Directories site/ Your application code lives here. This is where you create pages and API routes. Rules: - Files must match pattern: (name).tsx or (name).ts - Files become routes automatically - Directories create nested routes - .ts files are API routes - .tsx files are pages (render HTML) Examples: site/(home).tsx \u2192 GET / site/(about).tsx \u2192 GET /about site/blog/($slug).tsx \u2192 GET /blog/:slug site/api/(users).ts \u2192 GET /api/users src/ Optional code supporting your application. Subdirectories: - components/ \u2014 Reusable Preact components - lib/ \u2014 Utility functions and helpers - middleware/ \u2014 Custom middleware - plugins/ \u2014 Custom plugins - styles/ \u2014 CSS/SCSS files - types/ \u2014 TypeScript type definitions Accessed via path alias: import { Header } from '@src/components/header' ; import { db } from '@src/lib/db' ; public/ Static assets that are copied to dist/ unchanged. Usage: - Put images in public/images/ - Reference as /images/logo.png in HTML - Includes robots.txt , sitemaps, etc. dist/ Generated output from build. Ignored by git. Structure after build: dist/ \u251c\u2500\u2500 index/ # Page routes \u2502 \u251c\u2500\u2500 index.html # / route \u2502 \u251c\u2500\u2500 about/ \u2502 \u2502 \u2514\u2500\u2500 index.html # /about \u2502 \u2514\u2500\u2500 posts/ \u2502 \u2514\u2500\u2500 1/ \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 api/ # API routes (SSR only) \u2514\u2500\u2500 assets/ # Static files File Organization Components Create reusable components in src/components/ : // src/components/button.tsx interface ButtonProps { text : string ; onClick : () => void ; } export function Button ({ text , onClick } : ButtonProps ) { return < button onClick = { onClick } > { text } < /button>; } Use in pages: // site/(home).tsx import { Button } from '@src/components/button' ; export default function Home () { return < Button text = \"Click me\" onClick = {() => alert ( 'Clicked!' )} /> ; } Utilities Create helpers in src/lib/ : // src/lib/api.ts export async function fetchUser ( id : string ) { const res = await fetch ( `/api/users/ ${ id } ` ); return res . json (); } // src/lib/validation.ts export function validateEmail ( email : string ) : boolean { return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ . test ( email ); } Use throughout: import { fetchUser } from '@src/lib/api' ; import { validateEmail } from '@src/lib/validation' ; Styles Keep styles organized: src/styles/ \u251c\u2500\u2500 globals.css # Global styles \u251c\u2500\u2500 layout.css # Layout components \u251c\u2500\u2500 typography.css # Typography \u2514\u2500\u2500 variables.css # CSS variables Import in pages: // site/(home).tsx import '@src/styles/globals.css' ; export default function Home () { return < h1 > Styled page < /h1>; } Or use inline styles: const styles = ` h1 { color: blue; } p { font-size: 16px; } ` ; export default function Home () { return ( < html > < head >< style > { styles } < /style></head> < body >< h1 > Heading < /h1></body> < /html> ); } Types Create type definitions in src/types/ : // src/types/user.ts export interface User { id : string ; name : string ; email : string ; createdAt : Date ; } export interface UserInput { name : string ; email : string ; } Use throughout: import type { User } from '@src/types/user' ; export async function getUser ( id : string ) : Promise < User > { // ... } Configuration Files jen.config.ts Main framework configuration: import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , // ... more options }; export default config ; tsconfig.json TypeScript configuration: { \"compilerOptions\" : { \"target\" : \"ES2022\" , \"module\" : \"ES2020\" , \"jsx\" : \"react-jsx\" , \"jsxImportSource\" : \"preact\" , \"strict\" : true , \"paths\" : { \"@src/*\" : [ \"src/*\" ] } } } .env Environment variables (not committed): DATABASE_URL=sqlite://./data.db API_KEY=secret123 package.json Dependencies and scripts: { \"scripts\" : { \"dev\" : \"node server.ts dev\" , \"build\" : \"node build.js\" , \"start\" : \"node server.ts start\" , \"typecheck\" : \"tsc --noEmit\" }, \"dependencies\" : { \"preact\" : \"^10.0.0\" } } Build Output Structure After running npm run build : dist/ \u251c\u2500\u2500 index/ \u2502 \u251c\u2500\u2500 index.html # / (homepage) \u2502 \u251c\u2500\u2500 about/ \u2502 \u2502 \u2514\u2500\u2500 index.html # /about \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u251c\u2500\u2500 1/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 index.html # /posts/1 \u2502 \u2502 \u2514\u2500\u2500 2/ \u2502 \u2502 \u2514\u2500\u2500 index.html # /posts/2 \u2502 \u2514\u2500\u2500 api/ # /api/* routes (if SSR) \u251c\u2500\u2500 styles.css \u251c\u2500\u2500 bundle.js \u2514\u2500\u2500 assets/ \u251c\u2500\u2500 images/ \u2514\u2500\u2500 fonts/ For SSR mode: dist/ \u251c\u2500\u2500 server.js # Runtime server \u251c\u2500\u2500 api/ # API route handlers \u2502 \u2514\u2500\u2500 users.js \u2514\u2500\u2500 pages/ # Page components \u2514\u2500\u2500 home.js Organization Best Practices Group by Feature For larger apps, organize by feature: src/ \u251c\u2500\u2500 features/ \u2502 \u251c\u2500\u2500 auth/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 types.ts \u2502 \u251c\u2500\u2500 users/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 types.ts \u2502 \u2514\u2500\u2500 posts/ \u2502 \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2514\u2500\u2500 types.ts Shared Code Keep truly shared code in src/ : src/ \u251c\u2500\u2500 components/ # Shared components \u251c\u2500\u2500 lib/ # Shared utilities \u251c\u2500\u2500 types/ # Shared types \u2514\u2500\u2500 middleware/ # Shared middleware Keep site/ Simple The site/ directory should mainly be route definitions that delegate to components: // site/(user).tsx import { UserProfile } from '@src/features/users/components/profile' ; import { getUser } from '@src/features/users/lib/api' ; export async function loader ( ctx : any ) { return { user : await getUser ( ctx . params . id ) }; } export default function UserPage ({ data } : any ) { return < UserProfile user = { data . user } /> ; } Next Steps Create your first component Organize your project Build your application","title":"Project Structure"},{"location":"core/structure/#directory-layout","text":"jen.js-app/ \u251c\u2500\u2500 site/ # Application routes and pages \u2502 \u251c\u2500\u2500 (home).tsx # Routes in Preact/JSX \u2502 \u251c\u2500\u2500 (about).tsx \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u251c\u2500\u2500 (index).tsx # /posts \u2192 index page \u2502 \u2502 \u2514\u2500\u2500 ($id).tsx # /posts/:id \u2192 dynamic page \u2502 \u2514\u2500\u2500 api/ \u2502 \u251c\u2500\u2500 (users).ts # /api/users \u2192 API endpoint \u2502 \u2514\u2500\u2500 v1/ \u2502 \u2514\u2500\u2500 (data).ts # /api/v1/data \u2192 nested API \u2502 \u251c\u2500\u2500 src/ # Framework and app code \u2502 \u251c\u2500\u2500 components/ # Reusable Preact components \u2502 \u2502 \u251c\u2500\u2500 header.tsx \u2502 \u2502 \u251c\u2500\u2500 footer.tsx \u2502 \u2502 \u2514\u2500\u2500 nav.tsx \u2502 \u251c\u2500\u2500 lib/ # Utility functions \u2502 \u2502 \u251c\u2500\u2500 db.ts # Database helpers \u2502 \u2502 \u251c\u2500\u2500 api.ts # API client \u2502 \u2502 \u2514\u2500\u2500 utils.ts # Utilities \u2502 \u251c\u2500\u2500 middleware/ # Express-style middleware \u2502 \u2502 \u251c\u2500\u2500 auth.ts \u2502 \u2502 \u2514\u2500\u2500 logging.ts \u2502 \u251c\u2500\u2500 plugins/ # Custom plugins \u2502 \u2502 \u2514\u2500\u2500 my-plugin.ts \u2502 \u2514\u2500\u2500 styles/ # Stylesheets \u2502 \u251c\u2500\u2500 globals.css \u2502 \u2514\u2500\u2500 components.css \u2502 \u251c\u2500\u2500 public/ # Static assets (copied as-is) \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u251c\u2500\u2500 robots.txt \u2502 \u2514\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 dist/ # Build output (generated) \u2502 \u251c\u2500\u2500 index/ \u2502 \u2502 \u2514\u2500\u2500 index.html # Rendered pages \u2502 \u251c\u2500\u2500 api/ # API routes (if SSR) \u2502 \u251c\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 styles.css \u2502 \u2514\u2500\u2500 bundle.js \u2502 \u251c\u2500\u2500 .env # Environment variables (not in git) \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 jen.config.ts # Framework configuration \u251c\u2500\u2500 tsconfig.json # TypeScript configuration \u251c\u2500\u2500 package.json # Dependencies and scripts \u2514\u2500\u2500 README.md","title":"Directory Layout"},{"location":"core/structure/#key-directories","text":"","title":"Key Directories"},{"location":"core/structure/#site","text":"Your application code lives here. This is where you create pages and API routes. Rules: - Files must match pattern: (name).tsx or (name).ts - Files become routes automatically - Directories create nested routes - .ts files are API routes - .tsx files are pages (render HTML) Examples: site/(home).tsx \u2192 GET / site/(about).tsx \u2192 GET /about site/blog/($slug).tsx \u2192 GET /blog/:slug site/api/(users).ts \u2192 GET /api/users","title":"site/"},{"location":"core/structure/#src","text":"Optional code supporting your application. Subdirectories: - components/ \u2014 Reusable Preact components - lib/ \u2014 Utility functions and helpers - middleware/ \u2014 Custom middleware - plugins/ \u2014 Custom plugins - styles/ \u2014 CSS/SCSS files - types/ \u2014 TypeScript type definitions Accessed via path alias: import { Header } from '@src/components/header' ; import { db } from '@src/lib/db' ;","title":"src/"},{"location":"core/structure/#public","text":"Static assets that are copied to dist/ unchanged. Usage: - Put images in public/images/ - Reference as /images/logo.png in HTML - Includes robots.txt , sitemaps, etc.","title":"public/"},{"location":"core/structure/#dist","text":"Generated output from build. Ignored by git. Structure after build: dist/ \u251c\u2500\u2500 index/ # Page routes \u2502 \u251c\u2500\u2500 index.html # / route \u2502 \u251c\u2500\u2500 about/ \u2502 \u2502 \u2514\u2500\u2500 index.html # /about \u2502 \u2514\u2500\u2500 posts/ \u2502 \u2514\u2500\u2500 1/ \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 api/ # API routes (SSR only) \u2514\u2500\u2500 assets/ # Static files","title":"dist/"},{"location":"core/structure/#file-organization","text":"","title":"File Organization"},{"location":"core/structure/#components","text":"Create reusable components in src/components/ : // src/components/button.tsx interface ButtonProps { text : string ; onClick : () => void ; } export function Button ({ text , onClick } : ButtonProps ) { return < button onClick = { onClick } > { text } < /button>; } Use in pages: // site/(home).tsx import { Button } from '@src/components/button' ; export default function Home () { return < Button text = \"Click me\" onClick = {() => alert ( 'Clicked!' )} /> ; }","title":"Components"},{"location":"core/structure/#utilities","text":"Create helpers in src/lib/ : // src/lib/api.ts export async function fetchUser ( id : string ) { const res = await fetch ( `/api/users/ ${ id } ` ); return res . json (); } // src/lib/validation.ts export function validateEmail ( email : string ) : boolean { return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ . test ( email ); } Use throughout: import { fetchUser } from '@src/lib/api' ; import { validateEmail } from '@src/lib/validation' ;","title":"Utilities"},{"location":"core/structure/#styles","text":"Keep styles organized: src/styles/ \u251c\u2500\u2500 globals.css # Global styles \u251c\u2500\u2500 layout.css # Layout components \u251c\u2500\u2500 typography.css # Typography \u2514\u2500\u2500 variables.css # CSS variables Import in pages: // site/(home).tsx import '@src/styles/globals.css' ; export default function Home () { return < h1 > Styled page < /h1>; } Or use inline styles: const styles = ` h1 { color: blue; } p { font-size: 16px; } ` ; export default function Home () { return ( < html > < head >< style > { styles } < /style></head> < body >< h1 > Heading < /h1></body> < /html> ); }","title":"Styles"},{"location":"core/structure/#types","text":"Create type definitions in src/types/ : // src/types/user.ts export interface User { id : string ; name : string ; email : string ; createdAt : Date ; } export interface UserInput { name : string ; email : string ; } Use throughout: import type { User } from '@src/types/user' ; export async function getUser ( id : string ) : Promise < User > { // ... }","title":"Types"},{"location":"core/structure/#configuration-files","text":"","title":"Configuration Files"},{"location":"core/structure/#jenconfigts","text":"Main framework configuration: import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , // ... more options }; export default config ;","title":"jen.config.ts"},{"location":"core/structure/#tsconfigjson","text":"TypeScript configuration: { \"compilerOptions\" : { \"target\" : \"ES2022\" , \"module\" : \"ES2020\" , \"jsx\" : \"react-jsx\" , \"jsxImportSource\" : \"preact\" , \"strict\" : true , \"paths\" : { \"@src/*\" : [ \"src/*\" ] } } }","title":"tsconfig.json"},{"location":"core/structure/#env","text":"Environment variables (not committed): DATABASE_URL=sqlite://./data.db API_KEY=secret123","title":".env"},{"location":"core/structure/#packagejson","text":"Dependencies and scripts: { \"scripts\" : { \"dev\" : \"node server.ts dev\" , \"build\" : \"node build.js\" , \"start\" : \"node server.ts start\" , \"typecheck\" : \"tsc --noEmit\" }, \"dependencies\" : { \"preact\" : \"^10.0.0\" } }","title":"package.json"},{"location":"core/structure/#build-output-structure","text":"After running npm run build : dist/ \u251c\u2500\u2500 index/ \u2502 \u251c\u2500\u2500 index.html # / (homepage) \u2502 \u251c\u2500\u2500 about/ \u2502 \u2502 \u2514\u2500\u2500 index.html # /about \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u251c\u2500\u2500 1/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 index.html # /posts/1 \u2502 \u2502 \u2514\u2500\u2500 2/ \u2502 \u2502 \u2514\u2500\u2500 index.html # /posts/2 \u2502 \u2514\u2500\u2500 api/ # /api/* routes (if SSR) \u251c\u2500\u2500 styles.css \u251c\u2500\u2500 bundle.js \u2514\u2500\u2500 assets/ \u251c\u2500\u2500 images/ \u2514\u2500\u2500 fonts/ For SSR mode: dist/ \u251c\u2500\u2500 server.js # Runtime server \u251c\u2500\u2500 api/ # API route handlers \u2502 \u2514\u2500\u2500 users.js \u2514\u2500\u2500 pages/ # Page components \u2514\u2500\u2500 home.js","title":"Build Output Structure"},{"location":"core/structure/#organization-best-practices","text":"","title":"Organization Best Practices"},{"location":"core/structure/#group-by-feature","text":"For larger apps, organize by feature: src/ \u251c\u2500\u2500 features/ \u2502 \u251c\u2500\u2500 auth/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 types.ts \u2502 \u251c\u2500\u2500 users/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 types.ts \u2502 \u2514\u2500\u2500 posts/ \u2502 \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2514\u2500\u2500 types.ts","title":"Group by Feature"},{"location":"core/structure/#shared-code","text":"Keep truly shared code in src/ : src/ \u251c\u2500\u2500 components/ # Shared components \u251c\u2500\u2500 lib/ # Shared utilities \u251c\u2500\u2500 types/ # Shared types \u2514\u2500\u2500 middleware/ # Shared middleware","title":"Shared Code"},{"location":"core/structure/#keep-site-simple","text":"The site/ directory should mainly be route definitions that delegate to components: // site/(user).tsx import { UserProfile } from '@src/features/users/components/profile' ; import { getUser } from '@src/features/users/lib/api' ; export async function loader ( ctx : any ) { return { user : await getUser ( ctx . params . id ) }; } export default function UserPage ({ data } : any ) { return < UserProfile user = { data . user } /> ; }","title":"Keep site/ Simple"},{"location":"core/structure/#next-steps","text":"Create your first component Organize your project Build your application","title":"Next Steps"},{"location":"features/api-routes/","text":"Build REST APIs with file-based routing. Create .ts files in site/api/ to define API endpoints. Basic API Route Create site/api/(users).ts : import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [] })); } else { res . writeHead ( 405 ); res . end ( 'Method Not Allowed' ); } } Access at GET /api/users Request Handling export async function handle ( req , res ) { console . log ( req . method ); // GET, POST, etc. console . log ( req . url ); // /api/users?page=1 console . log ( req . headers ); // Headers object // Route methods if ( req . method === 'GET' ) { // Handle GET } else if ( req . method === 'POST' ) { // Handle POST } else if ( req . method === 'PUT' ) { // Handle PUT } else if ( req . method === 'DELETE' ) { // Handle DELETE } } Reading Request Body export async function handle ( req , res ) { let body = '' ; req . on ( 'data' , chunk => { body += chunk . toString (); }); req . on ( 'end' , () => { try { const data = JSON . parse ( body ); res . writeHead ( 200 ); res . end ( JSON . stringify ({ success : true , data })); } catch ( err ) { res . writeHead ( 400 ); res . end ( 'Invalid JSON' ); } }); } Query Parameters export async function handle ( req , res ) { const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); const page = url . searchParams . get ( 'page' ) || '1' ; const limit = url . searchParams . get ( 'limit' ) || '10' ; const users = await getUsers ( parseInt ( page ), parseInt ( limit )); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( users )); } Response Headers export async function handle ( req , res ) { res . writeHead ( 200 , { 'content-type' : 'application/json' , 'cache-control' : 'public, max-age=3600' , 'x-custom-header' : 'value' }); res . end ( JSON . stringify ({ data : [] })); } Status Codes // Success res . writeHead ( 200 ); // OK res . writeHead ( 201 ); // Created res . writeHead ( 204 ); // No Content // Errors res . writeHead ( 400 ); // Bad Request res . writeHead ( 401 ); // Unauthorized res . writeHead ( 403 ); // Forbidden res . writeHead ( 404 ); // Not Found res . writeHead ( 500 ); // Server Error JSON Responses function sendJSON ( res , data , status = 200 ) { res . writeHead ( status , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( data )); } export async function handle ( req , res ) { if ( req . method === 'GET' ) { sendJSON ( res , { users : [] }); } else { sendJSON ( res , { error : 'Method not allowed' }, 405 ); } } Dynamic Routes Create nested API routes with dynamic parameters: // site/api/users/($id).ts export async function handle ( req , res ) { const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); const userId = url . pathname . split ( '/' )[ 3 ]; // Extract from path if ( req . method === 'GET' ) { const user = await getUser ( userId ); if ( user ) { sendJSON ( res , user ); } else { sendJSON ( res , { error : 'Not found' }, 404 ); } } } Access at GET /api/users/123 Error Handling export async function handle ( req , res ) { try { const data = await fetchData (); sendJSON ( res , data ); } catch ( err ) { console . error ( err ); sendJSON ( res , { error : 'Server error' }, 500 ); } } CORS Handle cross-origin requests: function setCORSHeaders ( res ) { res . setHeader ( 'Access-Control-Allow-Origin' , '*' ); res . setHeader ( 'Access-Control-Allow-Methods' , 'GET, POST, PUT, DELETE' ); res . setHeader ( 'Access-Control-Allow-Headers' , 'Content-Type' ); } export async function handle ( req , res ) { setCORSHeaders ( res ); if ( req . method === 'OPTIONS' ) { res . writeHead ( 200 ); res . end (); return ; } // Handle request } Authentication import { verifyToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { sendJSON ( res , { error : 'Unauthorized' }, 401 ); return ; } try { const payload = verifyToken ( token ); // Use payload.userId, etc. } catch ( err ) { sendJSON ( res , { error : 'Invalid token' }, 401 ); } } Validation function validateInput ( data ) { if ( ! data . email || ! data . name ) { return { valid : false , error : 'Missing fields' }; } if ( ! /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ . test ( data . email )) { return { valid : false , error : 'Invalid email' }; } return { valid : true }; } export async function handle ( req , res ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const data = JSON . parse ( body ); const validation = validateInput ( data ); if ( ! validation . valid ) { sendJSON ( res , { error : validation.error }, 400 ); return ; } // Process valid data }); } File Uploads export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { // Parse multipart/form-data or base64 const file = parseUpload ( body ); // Save file await saveFile ( file ); sendJSON ( res , { success : true }); }); } } Streaming Response export async function handle ( req , res ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . write ( '{\"items\":[' ); for ( let i = 0 ; i < 1000 ; i ++ ) { res . write ( JSON . stringify ({ id : i })); if ( i < 999 ) res . write ( ',' ); } res . write ( ']}' ); res . end (); } Best Practices Validate all inputs Use appropriate HTTP methods Return meaningful status codes Implement authentication Handle errors gracefully Use proper error responses Document your API Version your API endpoints","title":"API Routes"},{"location":"features/api-routes/#basic-api-route","text":"Create site/api/(users).ts : import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [] })); } else { res . writeHead ( 405 ); res . end ( 'Method Not Allowed' ); } } Access at GET /api/users","title":"Basic API Route"},{"location":"features/api-routes/#request-handling","text":"export async function handle ( req , res ) { console . log ( req . method ); // GET, POST, etc. console . log ( req . url ); // /api/users?page=1 console . log ( req . headers ); // Headers object // Route methods if ( req . method === 'GET' ) { // Handle GET } else if ( req . method === 'POST' ) { // Handle POST } else if ( req . method === 'PUT' ) { // Handle PUT } else if ( req . method === 'DELETE' ) { // Handle DELETE } }","title":"Request Handling"},{"location":"features/api-routes/#reading-request-body","text":"export async function handle ( req , res ) { let body = '' ; req . on ( 'data' , chunk => { body += chunk . toString (); }); req . on ( 'end' , () => { try { const data = JSON . parse ( body ); res . writeHead ( 200 ); res . end ( JSON . stringify ({ success : true , data })); } catch ( err ) { res . writeHead ( 400 ); res . end ( 'Invalid JSON' ); } }); }","title":"Reading Request Body"},{"location":"features/api-routes/#query-parameters","text":"export async function handle ( req , res ) { const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); const page = url . searchParams . get ( 'page' ) || '1' ; const limit = url . searchParams . get ( 'limit' ) || '10' ; const users = await getUsers ( parseInt ( page ), parseInt ( limit )); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( users )); }","title":"Query Parameters"},{"location":"features/api-routes/#response-headers","text":"export async function handle ( req , res ) { res . writeHead ( 200 , { 'content-type' : 'application/json' , 'cache-control' : 'public, max-age=3600' , 'x-custom-header' : 'value' }); res . end ( JSON . stringify ({ data : [] })); }","title":"Response Headers"},{"location":"features/api-routes/#status-codes","text":"// Success res . writeHead ( 200 ); // OK res . writeHead ( 201 ); // Created res . writeHead ( 204 ); // No Content // Errors res . writeHead ( 400 ); // Bad Request res . writeHead ( 401 ); // Unauthorized res . writeHead ( 403 ); // Forbidden res . writeHead ( 404 ); // Not Found res . writeHead ( 500 ); // Server Error","title":"Status Codes"},{"location":"features/api-routes/#json-responses","text":"function sendJSON ( res , data , status = 200 ) { res . writeHead ( status , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( data )); } export async function handle ( req , res ) { if ( req . method === 'GET' ) { sendJSON ( res , { users : [] }); } else { sendJSON ( res , { error : 'Method not allowed' }, 405 ); } }","title":"JSON Responses"},{"location":"features/api-routes/#dynamic-routes","text":"Create nested API routes with dynamic parameters: // site/api/users/($id).ts export async function handle ( req , res ) { const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); const userId = url . pathname . split ( '/' )[ 3 ]; // Extract from path if ( req . method === 'GET' ) { const user = await getUser ( userId ); if ( user ) { sendJSON ( res , user ); } else { sendJSON ( res , { error : 'Not found' }, 404 ); } } } Access at GET /api/users/123","title":"Dynamic Routes"},{"location":"features/api-routes/#error-handling","text":"export async function handle ( req , res ) { try { const data = await fetchData (); sendJSON ( res , data ); } catch ( err ) { console . error ( err ); sendJSON ( res , { error : 'Server error' }, 500 ); } }","title":"Error Handling"},{"location":"features/api-routes/#cors","text":"Handle cross-origin requests: function setCORSHeaders ( res ) { res . setHeader ( 'Access-Control-Allow-Origin' , '*' ); res . setHeader ( 'Access-Control-Allow-Methods' , 'GET, POST, PUT, DELETE' ); res . setHeader ( 'Access-Control-Allow-Headers' , 'Content-Type' ); } export async function handle ( req , res ) { setCORSHeaders ( res ); if ( req . method === 'OPTIONS' ) { res . writeHead ( 200 ); res . end (); return ; } // Handle request }","title":"CORS"},{"location":"features/api-routes/#authentication","text":"import { verifyToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { sendJSON ( res , { error : 'Unauthorized' }, 401 ); return ; } try { const payload = verifyToken ( token ); // Use payload.userId, etc. } catch ( err ) { sendJSON ( res , { error : 'Invalid token' }, 401 ); } }","title":"Authentication"},{"location":"features/api-routes/#validation","text":"function validateInput ( data ) { if ( ! data . email || ! data . name ) { return { valid : false , error : 'Missing fields' }; } if ( ! /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ . test ( data . email )) { return { valid : false , error : 'Invalid email' }; } return { valid : true }; } export async function handle ( req , res ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const data = JSON . parse ( body ); const validation = validateInput ( data ); if ( ! validation . valid ) { sendJSON ( res , { error : validation.error }, 400 ); return ; } // Process valid data }); }","title":"Validation"},{"location":"features/api-routes/#file-uploads","text":"export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { // Parse multipart/form-data or base64 const file = parseUpload ( body ); // Save file await saveFile ( file ); sendJSON ( res , { success : true }); }); } }","title":"File Uploads"},{"location":"features/api-routes/#streaming-response","text":"export async function handle ( req , res ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . write ( '{\"items\":[' ); for ( let i = 0 ; i < 1000 ; i ++ ) { res . write ( JSON . stringify ({ id : i })); if ( i < 999 ) res . write ( ',' ); } res . write ( ']}' ); res . end (); }","title":"Streaming Response"},{"location":"features/api-routes/#best-practices","text":"Validate all inputs Use appropriate HTTP methods Return meaningful status codes Implement authentication Handle errors gracefully Use proper error responses Document your API Version your API endpoints","title":"Best Practices"},{"location":"features/auth/","text":"Jen.js includes built-in JWT authentication utilities for securing your application. JWT Authentication Basic Setup import { signToken , verifyToken } from '@src/auth/jwt' ; // Create a token const token = signToken ({ userId : '123' }, '7d' ); // Verify a token const payload = verifyToken ( token ); Creating Tokens Sign a token with user data: const token = signToken ( { userId : user.id , email : user.email , role : user.role }, '7d' // Expires in 7 days ); Verifying Tokens Verify and decode tokens: try { const payload = verifyToken ( token ); console . log ( payload . userId ); // Access claims } catch ( err ) { console . error ( 'Invalid token' ); } Login Route Create an API route for login: // site/api/(login).ts import { signToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const { email , password } = JSON . parse ( body ); // Verify credentials (check database) const user = await verifyCredentials ( email , password ); if ( user ) { const token = signToken ({ userId : user.id }, '7d' ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ token })); } else { res . writeHead ( 401 ); res . end ( 'Invalid credentials' ); } }); } } Middleware for Protected Routes Create auth middleware: // src/middleware/auth.ts import { verifyToken } from '@src/auth/jwt' ; export async function authMiddleware ( req , res , next ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( 'No token provided' ); return ; } try { const payload = verifyToken ( token ); req . user = payload ; next (); } catch ( err ) { res . writeHead ( 401 ); res . end ( 'Invalid token' ); } } Protected Pages // site/dashboard/($userId).tsx import { verifyToken } from '@src/auth/jwt' ; export async function loader ( ctx ) { const token = ctx . request . headers . authorization ? . split ( ' ' )[ 1 ]; try { const payload = verifyToken ( token ); // Token is valid, load user data return { user : payload }; } catch ( err ) { // Redirect to login ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } } export default function Dashboard ({ data }) { return < h1 > Welcome , { data . user . userId } < /h1>; } Configuration In jen.config.ts : const config : FrameworkConfig = { auth : { secret : process.env.JWT_SECRET , algorithm : 'HS256' , issuer : 'your-app' } }; Best Practices Use environment variables for secrets Set appropriate expiration (shorter = more secure) Validate tokens on protected routes Use HTTPS in production Store tokens securely on client (httpOnly cookies) Implement refresh tokens for long sessions Hash passwords before storing","title":"Authentication"},{"location":"features/auth/#jwt-authentication","text":"","title":"JWT Authentication"},{"location":"features/auth/#basic-setup","text":"import { signToken , verifyToken } from '@src/auth/jwt' ; // Create a token const token = signToken ({ userId : '123' }, '7d' ); // Verify a token const payload = verifyToken ( token );","title":"Basic Setup"},{"location":"features/auth/#creating-tokens","text":"Sign a token with user data: const token = signToken ( { userId : user.id , email : user.email , role : user.role }, '7d' // Expires in 7 days );","title":"Creating Tokens"},{"location":"features/auth/#verifying-tokens","text":"Verify and decode tokens: try { const payload = verifyToken ( token ); console . log ( payload . userId ); // Access claims } catch ( err ) { console . error ( 'Invalid token' ); }","title":"Verifying Tokens"},{"location":"features/auth/#login-route","text":"Create an API route for login: // site/api/(login).ts import { signToken } from '@src/auth/jwt' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const { email , password } = JSON . parse ( body ); // Verify credentials (check database) const user = await verifyCredentials ( email , password ); if ( user ) { const token = signToken ({ userId : user.id }, '7d' ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ token })); } else { res . writeHead ( 401 ); res . end ( 'Invalid credentials' ); } }); } }","title":"Login Route"},{"location":"features/auth/#middleware-for-protected-routes","text":"Create auth middleware: // src/middleware/auth.ts import { verifyToken } from '@src/auth/jwt' ; export async function authMiddleware ( req , res , next ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( 'No token provided' ); return ; } try { const payload = verifyToken ( token ); req . user = payload ; next (); } catch ( err ) { res . writeHead ( 401 ); res . end ( 'Invalid token' ); } }","title":"Middleware for Protected Routes"},{"location":"features/auth/#protected-pages","text":"// site/dashboard/($userId).tsx import { verifyToken } from '@src/auth/jwt' ; export async function loader ( ctx ) { const token = ctx . request . headers . authorization ? . split ( ' ' )[ 1 ]; try { const payload = verifyToken ( token ); // Token is valid, load user data return { user : payload }; } catch ( err ) { // Redirect to login ctx . response . writeHead ( 302 , { location : '/login' }); ctx . response . end (); return {}; } } export default function Dashboard ({ data }) { return < h1 > Welcome , { data . user . userId } < /h1>; }","title":"Protected Pages"},{"location":"features/auth/#configuration","text":"In jen.config.ts : const config : FrameworkConfig = { auth : { secret : process.env.JWT_SECRET , algorithm : 'HS256' , issuer : 'your-app' } };","title":"Configuration"},{"location":"features/auth/#best-practices","text":"Use environment variables for secrets Set appropriate expiration (shorter = more secure) Validate tokens on protected routes Use HTTPS in production Store tokens securely on client (httpOnly cookies) Implement refresh tokens for long sessions Hash passwords before storing","title":"Best Practices"},{"location":"features/cache/","text":"Jen.js provides built-in caching capabilities for improving performance. HTTP Caching Control how browsers and CDNs cache responses: export async function loader ( ctx ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); return { data : await fetchData () }; } Cache-Control Directives public \u2014 Can be cached by any cache private \u2014 Only browser cache, not CDN max-age=3600 \u2014 Cache for 3600 seconds no-cache \u2014 Must revalidate before serving no-store \u2014 Never cache stale-while-revalidate=86400 \u2014 Serve stale while updating Page-Level Caching Cache entire page responses: export async function loader ( ctx ) { const cached = await getFromCache ( `page- ${ ctx . params . id } ` ); if ( cached ) { return cached ; } const data = await expensiveOperation (); await setInCache ( `page- ${ ctx . params . id } ` , data , 3600 ); return data ; } Database Query Caching Cache frequently accessed data: async function getCachedUser ( userId ) { const key = `user- ${ userId } ` ; // Try cache first let user = await cache . get ( key ); if ( ! user ) { // Not cached, fetch from DB user = await db . findOne ( 'users' , { id : userId }); // Cache for 1 hour await cache . set ( key , user , 3600 ); } return user ; } Redis Caching For high-performance caching: import { createClient } from 'redis' ; const redis = createClient ({ url : process.env.REDIS_URL }); async function cacheData ( key , data , ttl = 3600 ) { await redis . setEx ( key , ttl , JSON . stringify ( data )); } async function getCachedData ( key ) { const data = await redis . get ( key ); return data ? JSON . parse ( data ) : null ; } Cache Invalidation Clear cache when data changes: // site/api/(users).ts export async function handle ( req , res ) { if ( req . method === 'POST' ) { const user = await createUser (...); // Invalidate user list cache await cache . delete ( 'users-list' ); res . writeHead ( 200 ); res . end ( JSON . stringify ({ user })); } } Best Practices Cache read-heavy data Set appropriate TTL Invalidate on updates Monitor cache hit rates Use Redis for distributed caching","title":"Caching"},{"location":"features/cache/#http-caching","text":"Control how browsers and CDNs cache responses: export async function loader ( ctx ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); return { data : await fetchData () }; }","title":"HTTP Caching"},{"location":"features/cache/#cache-control-directives","text":"public \u2014 Can be cached by any cache private \u2014 Only browser cache, not CDN max-age=3600 \u2014 Cache for 3600 seconds no-cache \u2014 Must revalidate before serving no-store \u2014 Never cache stale-while-revalidate=86400 \u2014 Serve stale while updating","title":"Cache-Control Directives"},{"location":"features/cache/#page-level-caching","text":"Cache entire page responses: export async function loader ( ctx ) { const cached = await getFromCache ( `page- ${ ctx . params . id } ` ); if ( cached ) { return cached ; } const data = await expensiveOperation (); await setInCache ( `page- ${ ctx . params . id } ` , data , 3600 ); return data ; }","title":"Page-Level Caching"},{"location":"features/cache/#database-query-caching","text":"Cache frequently accessed data: async function getCachedUser ( userId ) { const key = `user- ${ userId } ` ; // Try cache first let user = await cache . get ( key ); if ( ! user ) { // Not cached, fetch from DB user = await db . findOne ( 'users' , { id : userId }); // Cache for 1 hour await cache . set ( key , user , 3600 ); } return user ; }","title":"Database Query Caching"},{"location":"features/cache/#redis-caching","text":"For high-performance caching: import { createClient } from 'redis' ; const redis = createClient ({ url : process.env.REDIS_URL }); async function cacheData ( key , data , ttl = 3600 ) { await redis . setEx ( key , ttl , JSON . stringify ( data )); } async function getCachedData ( key ) { const data = await redis . get ( key ); return data ? JSON . parse ( data ) : null ; }","title":"Redis Caching"},{"location":"features/cache/#cache-invalidation","text":"Clear cache when data changes: // site/api/(users).ts export async function handle ( req , res ) { if ( req . method === 'POST' ) { const user = await createUser (...); // Invalidate user list cache await cache . delete ( 'users-list' ); res . writeHead ( 200 ); res . end ( JSON . stringify ({ user })); } }","title":"Cache Invalidation"},{"location":"features/cache/#best-practices","text":"Cache read-heavy data Set appropriate TTL Invalidate on updates Monitor cache hit rates Use Redis for distributed caching","title":"Best Practices"},{"location":"features/database/","text":"Jen.js includes a multi-driver database abstraction layer. Use SQLite, PostgreSQL, MySQL, MongoDB, or jDB. Supported Databases Database Type Use Case SQLite Embedded Development, small projects, offline-first PostgreSQL SQL Production, complex queries, ACID MySQL SQL Production, shared hosting MongoDB NoSQL Flexible schema, document storage jDB Custom Embedded, lightweight, no dependencies Basic Usage Setup Configure in jen.config.ts : import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { database : { default : { type : 'sqlite' , config : { filename : './data.db' } } } }; export default config ; Or use environment variables: # .env DATABASE_URL = postgresql://user:password@localhost/mydb const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } } } }; Connect and Query src/lib/db.ts import { DB } from '@src/db' ; import type { FrameworkConfig } from '@src/core/config' ; let db : DB ; export async function initDB ( config : FrameworkConfig ) { db = new DB ( config . database . default ); await db . connect (); return db ; } export function getDB () { return db ; } Use in routes: // site/api/(users).ts import { getDB } from '@src/lib/db' ; export async function handle ( req : any , res : any ) { const db = getDB (); const users = await db . find ( 'users' , {}); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( users )); } SQLite Embedded database, zero configuration. Configuration const config : FrameworkConfig = { database : { default : { type : 'sqlite' , config : { filename : './data.db' } } } }; Usage const db = new DB ({ type : 'sqlite' }); await db . connect (); // Create table await db . exec ( ` CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY, name TEXT, email TEXT UNIQUE ) ` ); // Insert await db . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); // Find const users = await db . find ( 'users' , { name : 'Alice' }); // Update await db . update ( 'users' , { id : 1 }, { name : 'Bob' }); // Delete await db . delete ( 'users' , { id : 1 }); PostgreSQL Production-grade SQL database. Configuration const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { host : 'localhost' , port : 5432 , database : 'myapp' , user : 'postgres' , password : process.env.DB_PASSWORD } } } }; Usage const db = new DB ({ type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } }); await db . connect (); // Migrations await db . exec ( ` CREATE TABLE users ( id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255) UNIQUE, created_at TIMESTAMP DEFAULT NOW() ); CREATE INDEX idx_email ON users(email); ` ); // Prepared statements const [ user ] = await db . find ( 'users' , { id : 1 }); MySQL Fast and reliable SQL database. Configuration const config : FrameworkConfig = { database : { default : { type : 'mysql' , config : { host : 'localhost' , user : 'root' , password : process.env.DB_PASSWORD , database : 'myapp' } } } }; Usage const db = new DB ({ type : 'mysql' , config : { connectionString : process.env.DATABASE_URL } }); await db . connect (); // Create table await db . exec ( ` CREATE TABLE articles ( id INT AUTO_INCREMENT PRIMARY KEY, title VARCHAR(255), content LONGTEXT, published BOOLEAN DEFAULT FALSE ); ` ); // Query const articles = await db . find ( 'articles' , { published : true }); MongoDB Flexible document database. Configuration const config : FrameworkConfig = { database : { default : { type : 'mongodb' , config : { url : 'mongodb://localhost:27017/myapp' } } } }; Usage const db = new DB ({ type : 'mongodb' , config : { url : process.env.MONGODB_URL } }); await db . connect (); // Insert documents await db . insert ( 'posts' , { title : 'Hello' , content : 'World' , tags : [ 'mongodb' , 'nodejs' ] }); // Find with queries const posts = await db . find ( 'posts' , { tags : { $in : [ 'nodejs' ] } }); // Update await db . update ( 'posts' , { _id : id }, { published : true }); // Delete await db . delete ( 'posts' , { archived : true }); jDB Jen's lightweight embedded database. Configuration const config : FrameworkConfig = { database : { default : { type : 'jdb' , config : { root : './data' , name : 'app' } } } }; Usage const db = new DB ({ type : 'jdb' , config : { root : './data' } }); await db . connect (); // Insert await db . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); // Find const users = await db . find ( 'users' , { name : 'Alice' }); // Update await db . update ( 'users' , { id : 1 }, { name : 'Bob' }); // Delete await db . delete ( 'users' , { id : 1 }); Perfect for development and small projects. Multiple Databases Connect to multiple databases: const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } }, connections : { cache : { type : 'redis' , config : { url : 'redis://localhost:6379' } }, search : { type : 'mongodb' , config : { url : 'mongodb://localhost:27017/search' } } } } }; Usage: const primaryDB = getDB (); const cacheDB = getDB ( 'cache' ); const searchDB = getDB ( 'search' ); Common Operations Create Table await db . exec ( ` CREATE TABLE IF NOT EXISTS posts ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, content TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) ` ); Insert await db . insert ( 'posts' , { title : 'Hello World' , content : 'This is my first post' }); Find One const post = await db . findOne ( 'posts' , { id : 1 }); Find Many const posts = await db . find ( 'posts' , {}); const published = await db . find ( 'posts' , { published : true }); Update await db . update ( 'posts' , { id : 1 }, { title : 'Updated Title' , published : true }); Delete await db . delete ( 'posts' , { id : 1 }); Count const count = await db . count ( 'posts' , {}); const published = await db . count ( 'posts' , { published : true }); Migrations Create migration files: src/migrations/001_create_users.ts export async function up ( db : DB ) { await db . exec ( ` CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE NOT NULL ) ` ); } export async function down ( db : DB ) { await db . exec ( 'DROP TABLE users' ); } Run migrations: npm run migrate Transactions Handle multiple operations atomically: const db = getDB (); try { await db . transaction ( async ( tx ) => { await tx . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); await tx . insert ( 'profiles' , { userId : lastId , bio : 'Hello' }); }); } catch ( err ) { console . error ( 'Transaction failed, rolled back' ); } Best Practices Use environment variables for database URLs Create indexes for frequently queried columns Use transactions for related operations Validate inputs before querying Handle connection pooling in production Monitor query performance Regular backups for important data Use migrations for schema changes","title":"Database"},{"location":"features/database/#supported-databases","text":"Database Type Use Case SQLite Embedded Development, small projects, offline-first PostgreSQL SQL Production, complex queries, ACID MySQL SQL Production, shared hosting MongoDB NoSQL Flexible schema, document storage jDB Custom Embedded, lightweight, no dependencies","title":"Supported Databases"},{"location":"features/database/#basic-usage","text":"","title":"Basic Usage"},{"location":"features/database/#setup","text":"Configure in jen.config.ts : import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { database : { default : { type : 'sqlite' , config : { filename : './data.db' } } } }; export default config ; Or use environment variables: # .env DATABASE_URL = postgresql://user:password@localhost/mydb const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } } } };","title":"Setup"},{"location":"features/database/#connect-and-query","text":"src/lib/db.ts import { DB } from '@src/db' ; import type { FrameworkConfig } from '@src/core/config' ; let db : DB ; export async function initDB ( config : FrameworkConfig ) { db = new DB ( config . database . default ); await db . connect (); return db ; } export function getDB () { return db ; } Use in routes: // site/api/(users).ts import { getDB } from '@src/lib/db' ; export async function handle ( req : any , res : any ) { const db = getDB (); const users = await db . find ( 'users' , {}); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( users )); }","title":"Connect and Query"},{"location":"features/database/#sqlite","text":"Embedded database, zero configuration.","title":"SQLite"},{"location":"features/database/#configuration","text":"const config : FrameworkConfig = { database : { default : { type : 'sqlite' , config : { filename : './data.db' } } } };","title":"Configuration"},{"location":"features/database/#usage","text":"const db = new DB ({ type : 'sqlite' }); await db . connect (); // Create table await db . exec ( ` CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY, name TEXT, email TEXT UNIQUE ) ` ); // Insert await db . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); // Find const users = await db . find ( 'users' , { name : 'Alice' }); // Update await db . update ( 'users' , { id : 1 }, { name : 'Bob' }); // Delete await db . delete ( 'users' , { id : 1 });","title":"Usage"},{"location":"features/database/#postgresql","text":"Production-grade SQL database.","title":"PostgreSQL"},{"location":"features/database/#configuration_1","text":"const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { host : 'localhost' , port : 5432 , database : 'myapp' , user : 'postgres' , password : process.env.DB_PASSWORD } } } };","title":"Configuration"},{"location":"features/database/#usage_1","text":"const db = new DB ({ type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } }); await db . connect (); // Migrations await db . exec ( ` CREATE TABLE users ( id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255) UNIQUE, created_at TIMESTAMP DEFAULT NOW() ); CREATE INDEX idx_email ON users(email); ` ); // Prepared statements const [ user ] = await db . find ( 'users' , { id : 1 });","title":"Usage"},{"location":"features/database/#mysql","text":"Fast and reliable SQL database.","title":"MySQL"},{"location":"features/database/#configuration_2","text":"const config : FrameworkConfig = { database : { default : { type : 'mysql' , config : { host : 'localhost' , user : 'root' , password : process.env.DB_PASSWORD , database : 'myapp' } } } };","title":"Configuration"},{"location":"features/database/#usage_2","text":"const db = new DB ({ type : 'mysql' , config : { connectionString : process.env.DATABASE_URL } }); await db . connect (); // Create table await db . exec ( ` CREATE TABLE articles ( id INT AUTO_INCREMENT PRIMARY KEY, title VARCHAR(255), content LONGTEXT, published BOOLEAN DEFAULT FALSE ); ` ); // Query const articles = await db . find ( 'articles' , { published : true });","title":"Usage"},{"location":"features/database/#mongodb","text":"Flexible document database.","title":"MongoDB"},{"location":"features/database/#configuration_3","text":"const config : FrameworkConfig = { database : { default : { type : 'mongodb' , config : { url : 'mongodb://localhost:27017/myapp' } } } };","title":"Configuration"},{"location":"features/database/#usage_3","text":"const db = new DB ({ type : 'mongodb' , config : { url : process.env.MONGODB_URL } }); await db . connect (); // Insert documents await db . insert ( 'posts' , { title : 'Hello' , content : 'World' , tags : [ 'mongodb' , 'nodejs' ] }); // Find with queries const posts = await db . find ( 'posts' , { tags : { $in : [ 'nodejs' ] } }); // Update await db . update ( 'posts' , { _id : id }, { published : true }); // Delete await db . delete ( 'posts' , { archived : true });","title":"Usage"},{"location":"features/database/#jdb","text":"Jen's lightweight embedded database.","title":"jDB"},{"location":"features/database/#configuration_4","text":"const config : FrameworkConfig = { database : { default : { type : 'jdb' , config : { root : './data' , name : 'app' } } } };","title":"Configuration"},{"location":"features/database/#usage_4","text":"const db = new DB ({ type : 'jdb' , config : { root : './data' } }); await db . connect (); // Insert await db . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); // Find const users = await db . find ( 'users' , { name : 'Alice' }); // Update await db . update ( 'users' , { id : 1 }, { name : 'Bob' }); // Delete await db . delete ( 'users' , { id : 1 }); Perfect for development and small projects.","title":"Usage"},{"location":"features/database/#multiple-databases","text":"Connect to multiple databases: const config : FrameworkConfig = { database : { default : { type : 'postgres' , config : { connectionString : process.env.DATABASE_URL } }, connections : { cache : { type : 'redis' , config : { url : 'redis://localhost:6379' } }, search : { type : 'mongodb' , config : { url : 'mongodb://localhost:27017/search' } } } } }; Usage: const primaryDB = getDB (); const cacheDB = getDB ( 'cache' ); const searchDB = getDB ( 'search' );","title":"Multiple Databases"},{"location":"features/database/#common-operations","text":"","title":"Common Operations"},{"location":"features/database/#create-table","text":"await db . exec ( ` CREATE TABLE IF NOT EXISTS posts ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, content TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) ` );","title":"Create Table"},{"location":"features/database/#insert","text":"await db . insert ( 'posts' , { title : 'Hello World' , content : 'This is my first post' });","title":"Insert"},{"location":"features/database/#find-one","text":"const post = await db . findOne ( 'posts' , { id : 1 });","title":"Find One"},{"location":"features/database/#find-many","text":"const posts = await db . find ( 'posts' , {}); const published = await db . find ( 'posts' , { published : true });","title":"Find Many"},{"location":"features/database/#update","text":"await db . update ( 'posts' , { id : 1 }, { title : 'Updated Title' , published : true });","title":"Update"},{"location":"features/database/#delete","text":"await db . delete ( 'posts' , { id : 1 });","title":"Delete"},{"location":"features/database/#count","text":"const count = await db . count ( 'posts' , {}); const published = await db . count ( 'posts' , { published : true });","title":"Count"},{"location":"features/database/#migrations","text":"Create migration files: src/migrations/001_create_users.ts export async function up ( db : DB ) { await db . exec ( ` CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE NOT NULL ) ` ); } export async function down ( db : DB ) { await db . exec ( 'DROP TABLE users' ); } Run migrations: npm run migrate","title":"Migrations"},{"location":"features/database/#transactions","text":"Handle multiple operations atomically: const db = getDB (); try { await db . transaction ( async ( tx ) => { await tx . insert ( 'users' , { name : 'Alice' , email : 'alice@example.com' }); await tx . insert ( 'profiles' , { userId : lastId , bio : 'Hello' }); }); } catch ( err ) { console . error ( 'Transaction failed, rolled back' ); }","title":"Transactions"},{"location":"features/database/#best-practices","text":"Use environment variables for database URLs Create indexes for frequently queried columns Use transactions for related operations Validate inputs before querying Handle connection pooling in production Monitor query performance Regular backups for important data Use migrations for schema changes","title":"Best Practices"},{"location":"features/middleware/","text":"Middleware allows you to process requests/responses globally or per-route. Express-style middleware system. Basic Middleware Create middleware in src/middleware/ : // src/middleware/logging.ts import type { IncomingMessage , ServerResponse } from 'node:http' ; export function loggingMiddleware ( req : IncomingMessage , res : ServerResponse , next : () => void ) { const start = Date . now (); const originalEnd = res . end ; res . end = function (... args ) { const duration = Date . now () - start ; console . log ( ` ${ req . method } ${ req . url } - ${ duration } ms` ); return originalEnd . apply ( res , args ); }; next (); } Global Middleware Register in jen.config.ts : import { loggingMiddleware } from '@src/middleware/logging' ; import { corsMiddleware } from '@src/middleware/cors' ; const config : FrameworkConfig = { middleware : [ loggingMiddleware , corsMiddleware ] }; CORS Middleware // src/middleware/cors.ts export function corsMiddleware ( req , res , next ) { res . setHeader ( 'Access-Control-Allow-Origin' , '*' ); res . setHeader ( 'Access-Control-Allow-Methods' , 'GET, POST, PUT, DELETE' ); res . setHeader ( 'Access-Control-Allow-Headers' , 'Content-Type, Authorization' ); if ( req . method === 'OPTIONS' ) { res . writeHead ( 200 ); res . end (); return ; } next (); } Authentication Middleware // src/middleware/auth.ts import { verifyToken } from '@src/auth/jwt' ; export function authMiddleware ( req , res , next ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( 'Unauthorized' ); return ; } try { const payload = verifyToken ( token ); req . user = payload ; next (); } catch ( err ) { res . writeHead ( 401 ); res . end ( 'Invalid token' ); } } Compression Middleware // src/middleware/compression.ts import { createGzip } from 'node:zlib' ; export function compressionMiddleware ( req , res , next ) { const acceptEncoding = req . headers [ 'accept-encoding' ] || '' ; if ( /gzip/ . test ( acceptEncoding )) { res . setHeader ( 'Content-Encoding' , 'gzip' ); const gzip = createGzip (); gzip . pipe ( res ); res . write = ( chunk ) => gzip . write ( chunk ); res . end = ( chunk ) => gzip . end ( chunk ); } next (); } Route-Specific Middleware Apply middleware to specific routes: // site/api/(users).ts import { authMiddleware } from '@src/middleware/auth' ; export const middleware = [ authMiddleware ]; export async function handle ( req , res ) { // Only authenticated requests reach here res . writeHead ( 200 ); res . end ( JSON . stringify ({ user : req.user })); } Request Body Parsing // src/middleware/bodyParser.ts export async function bodyParserMiddleware ( req , res , next ) { let body = '' ; req . on ( 'data' , chunk => { body += chunk . toString (); }); req . on ( 'end' , () => { try { req . body = JSON . parse ( body ); } catch { req . body = {}; } next (); }); } Use in routes: export async function handle ( req , res ) { const { name , email } = req . body ; // Process... } Rate Limiting // src/middleware/rateLimit.ts const requests = new Map (); export function rateLimitMiddleware ( req , res , next ) { const ip = req . headers [ 'x-forwarded-for' ] || 'unknown' ; const now = Date . now (); if ( ! requests . has ( ip )) { requests . set ( ip , []); } const userRequests = requests . get ( ip ). filter ( t => now - t < 60000 ); userRequests . push ( now ); requests . set ( ip , userRequests ); if ( userRequests . length > 100 ) { // 100 requests per minute res . writeHead ( 429 ); res . end ( 'Too many requests' ); return ; } next (); } Error Handling Middleware // src/middleware/errorHandler.ts export function errorHandlerMiddleware ( req , res , next ) { const originalEnd = res . end ; res . end = function (... args ) { if ( res . statusCode >= 400 ) { console . error ( `Error: ${ res . statusCode } - ${ req . url } ` ); } return originalEnd . apply ( res , args ); }; next (); } Custom Middleware Pattern export function myMiddleware ( options = {}) { return ( req , res , next ) => { // Modify request/response req . custom = options ; // Call next middleware next (); }; } // Use: const config = { middleware : [ myMiddleware ({ key : 'value' }) ] }; Middleware Ordering Order matters \u2014 middleware runs in order specified: const config = { middleware : [ compressionMiddleware , // 1. Compress response corsMiddleware , // 2. Add CORS headers bodyParserMiddleware , // 3. Parse body authMiddleware , // 4. Verify auth loggingMiddleware // 5. Log request ] }; Async Middleware Middleware can be async: export async function asyncMiddleware ( req , res , next ) { const isAllowed = await checkPermissions ( req ); if ( ! isAllowed ) { res . writeHead ( 403 ); res . end ( 'Forbidden' ); return ; } next (); } Best Practices Keep middleware focused and single-purpose Use proper error handling Order middleware carefully Don't block request processing Use async/await for I/O operations Document middleware behavior Test middleware independently","title":"Middleware"},{"location":"features/middleware/#basic-middleware","text":"Create middleware in src/middleware/ : // src/middleware/logging.ts import type { IncomingMessage , ServerResponse } from 'node:http' ; export function loggingMiddleware ( req : IncomingMessage , res : ServerResponse , next : () => void ) { const start = Date . now (); const originalEnd = res . end ; res . end = function (... args ) { const duration = Date . now () - start ; console . log ( ` ${ req . method } ${ req . url } - ${ duration } ms` ); return originalEnd . apply ( res , args ); }; next (); }","title":"Basic Middleware"},{"location":"features/middleware/#global-middleware","text":"Register in jen.config.ts : import { loggingMiddleware } from '@src/middleware/logging' ; import { corsMiddleware } from '@src/middleware/cors' ; const config : FrameworkConfig = { middleware : [ loggingMiddleware , corsMiddleware ] };","title":"Global Middleware"},{"location":"features/middleware/#cors-middleware","text":"// src/middleware/cors.ts export function corsMiddleware ( req , res , next ) { res . setHeader ( 'Access-Control-Allow-Origin' , '*' ); res . setHeader ( 'Access-Control-Allow-Methods' , 'GET, POST, PUT, DELETE' ); res . setHeader ( 'Access-Control-Allow-Headers' , 'Content-Type, Authorization' ); if ( req . method === 'OPTIONS' ) { res . writeHead ( 200 ); res . end (); return ; } next (); }","title":"CORS Middleware"},{"location":"features/middleware/#authentication-middleware","text":"// src/middleware/auth.ts import { verifyToken } from '@src/auth/jwt' ; export function authMiddleware ( req , res , next ) { const token = req . headers . authorization ? . split ( ' ' )[ 1 ]; if ( ! token ) { res . writeHead ( 401 ); res . end ( 'Unauthorized' ); return ; } try { const payload = verifyToken ( token ); req . user = payload ; next (); } catch ( err ) { res . writeHead ( 401 ); res . end ( 'Invalid token' ); } }","title":"Authentication Middleware"},{"location":"features/middleware/#compression-middleware","text":"// src/middleware/compression.ts import { createGzip } from 'node:zlib' ; export function compressionMiddleware ( req , res , next ) { const acceptEncoding = req . headers [ 'accept-encoding' ] || '' ; if ( /gzip/ . test ( acceptEncoding )) { res . setHeader ( 'Content-Encoding' , 'gzip' ); const gzip = createGzip (); gzip . pipe ( res ); res . write = ( chunk ) => gzip . write ( chunk ); res . end = ( chunk ) => gzip . end ( chunk ); } next (); }","title":"Compression Middleware"},{"location":"features/middleware/#route-specific-middleware","text":"Apply middleware to specific routes: // site/api/(users).ts import { authMiddleware } from '@src/middleware/auth' ; export const middleware = [ authMiddleware ]; export async function handle ( req , res ) { // Only authenticated requests reach here res . writeHead ( 200 ); res . end ( JSON . stringify ({ user : req.user })); }","title":"Route-Specific Middleware"},{"location":"features/middleware/#request-body-parsing","text":"// src/middleware/bodyParser.ts export async function bodyParserMiddleware ( req , res , next ) { let body = '' ; req . on ( 'data' , chunk => { body += chunk . toString (); }); req . on ( 'end' , () => { try { req . body = JSON . parse ( body ); } catch { req . body = {}; } next (); }); } Use in routes: export async function handle ( req , res ) { const { name , email } = req . body ; // Process... }","title":"Request Body Parsing"},{"location":"features/middleware/#rate-limiting","text":"// src/middleware/rateLimit.ts const requests = new Map (); export function rateLimitMiddleware ( req , res , next ) { const ip = req . headers [ 'x-forwarded-for' ] || 'unknown' ; const now = Date . now (); if ( ! requests . has ( ip )) { requests . set ( ip , []); } const userRequests = requests . get ( ip ). filter ( t => now - t < 60000 ); userRequests . push ( now ); requests . set ( ip , userRequests ); if ( userRequests . length > 100 ) { // 100 requests per minute res . writeHead ( 429 ); res . end ( 'Too many requests' ); return ; } next (); }","title":"Rate Limiting"},{"location":"features/middleware/#error-handling-middleware","text":"// src/middleware/errorHandler.ts export function errorHandlerMiddleware ( req , res , next ) { const originalEnd = res . end ; res . end = function (... args ) { if ( res . statusCode >= 400 ) { console . error ( `Error: ${ res . statusCode } - ${ req . url } ` ); } return originalEnd . apply ( res , args ); }; next (); }","title":"Error Handling Middleware"},{"location":"features/middleware/#custom-middleware-pattern","text":"export function myMiddleware ( options = {}) { return ( req , res , next ) => { // Modify request/response req . custom = options ; // Call next middleware next (); }; } // Use: const config = { middleware : [ myMiddleware ({ key : 'value' }) ] };","title":"Custom Middleware Pattern"},{"location":"features/middleware/#middleware-ordering","text":"Order matters \u2014 middleware runs in order specified: const config = { middleware : [ compressionMiddleware , // 1. Compress response corsMiddleware , // 2. Add CORS headers bodyParserMiddleware , // 3. Parse body authMiddleware , // 4. Verify auth loggingMiddleware // 5. Log request ] };","title":"Middleware Ordering"},{"location":"features/middleware/#async-middleware","text":"Middleware can be async: export async function asyncMiddleware ( req , res , next ) { const isAllowed = await checkPermissions ( req ); if ( ! isAllowed ) { res . writeHead ( 403 ); res . end ( 'Forbidden' ); return ; } next (); }","title":"Async Middleware"},{"location":"features/middleware/#best-practices","text":"Keep middleware focused and single-purpose Use proper error handling Order middleware carefully Don't block request processing Use async/await for I/O operations Document middleware behavior Test middleware independently","title":"Best Practices"},{"location":"features/plugins/","text":"Extend Jen.js functionality with plugins. Create custom plugins to hook into build, serve, and deploy lifecycle. Plugin Basics Create a plugin in src/plugins/ : // src/plugins/my-plugin.ts export default { name : 'my-plugin' , version : '1.0.0' , description : 'My custom plugin' , onBuild : async ( context ) => { console . log ( 'Building...' ); }, onServe : async ( context ) => { console . log ( 'Serving...' ); }, onDeploy : async ( context ) => { console . log ( 'Deploying...' ); } }; Register Plugin In jen.config.ts : import myPlugin from '@src/plugins/my-plugin' ; const config : FrameworkConfig = { plugins : [ myPlugin , '@jen/plugin-analytics' , // npm package './src/plugins/custom.ts' ] }; Plugin Hooks onBuild Runs during build (SSG): export default { name : 'build-plugin' , onBuild : async ( context ) => { const { routes , config } = context ; // Process routes console . log ( `Building ${ routes . length } routes` ); // Generate additional files await generateSitemap ( routes ); } }; onServe Runs when dev server starts: export default { name : 'serve-plugin' , onServe : async ( context ) => { const { server , config } = context ; // Add custom routes server . use ( '/custom' , ( req , res ) => { res . end ( 'Custom route' ); }); console . log ( 'Dev server ready' ); } }; onDeploy Runs during deployment: export default { name : 'deploy-plugin' , onDeploy : async ( context ) => { const { distDir , config } = context ; // Upload to CDN await uploadToS3 ( distDir ); console . log ( 'Deployment complete' ); } }; Example Plugins Sitemap Generator // src/plugins/sitemap.ts export default { name : 'sitemap-generator' , onBuild : async ( context ) => { const { routes } = context ; const sitemap = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' ; + '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\\n' + routes . map ( route => `<url><loc> ${ route . path } </loc></url>` ). join ( '\\n' ) + '</urlset>' ; await fs . writeFile ( 'dist/sitemap.xml' , sitemap ); } }; Analytics Plugin // src/plugins/analytics.ts export default { name : 'analytics' , onBuild : async ( context ) => { const { distDir } = context ; // Add analytics script to all HTML files const files = glob . sync ( ` ${ distDir } /**/*.html` ); for ( const file of files ) { let content = fs . readFileSync ( file , 'utf-8' ); content = content . replace ( '</head>' , '<script src=\"/analytics.js\"></script>\\n</head>' ); fs . writeFileSync ( file , content ); } } }; Image Optimization Plugin // src/plugins/image-optimizer.ts export default { name : 'image-optimizer' , onBuild : async ( context ) => { const { distDir } = context ; const images = glob . sync ( ` ${ distDir } /**/*.{jpg,png}` ); for ( const image of images ) { // Compress image await sharp ( image ) . resize ( 1920 , 1080 , { fit : 'inside' }) . toFile ( image ); } } }; Plugin Context Plugins receive context with: interface PluginContext { config : FrameworkConfig ; // Framework config routes : Route []; // Discovered routes distDir : string ; // Build output directory siteDir : string ; // Source directory server? : ExpressApp ; // Dev server (in onServe) isDev : boolean ; // Development mode? timestamp : Date ; // Build/serve timestamp } Creating Reusable Plugins Export as npm package: { \"name\" : \"@myorg/jen-plugin-custom\" , \"version\" : \"1.0.0\" , \"main\" : \"dist/index.js\" , \"types\" : \"dist/index.d.ts\" } // src/index.ts export default { name : '@myorg/custom' , onBuild : async ( context ) => { // Plugin logic } }; Install and use: npm install @myorg/jen-plugin-custom import customPlugin from '@myorg/jen-plugin-custom' ; const config = { plugins : [ customPlugin ] }; Plugin Configuration Pass options to plugins: // src/plugins/configurable.ts export default function createPlugin ( options = {}) { return { name : 'configurable' , onBuild : async ( context ) => { if ( options . enabled ) { // Run plugin } } }; } Use with configuration: import createPlugin from '@src/plugins/configurable' ; const config = { plugins : [ createPlugin ({ enabled : true , setting : 'value' }) ] }; Error Handling Plugins should handle errors gracefully: export default { name : 'safe-plugin' , onBuild : async ( context ) => { try { const result = await riskyOperation (); console . log ( 'Success:' , result ); } catch ( err ) { console . error ( 'Plugin error:' , err ); // Don't throw \u2014 let build continue } } }; Best Practices Use descriptive plugin names Include version information Handle errors gracefully Document plugin options Use namespaces for organization Test plugins thoroughly Publish reusable plugins to npm Provide TypeScript types Testing Plugins // plugin.test.ts import plugin from '@src/plugins/my-plugin' ; test ( 'plugin runs on build' , async () => { const context = { routes : [{ path : '/' }], config : {}, distDir : './dist' }; await plugin . onBuild ( context ); // Assert plugin behavior }); Next Steps Create a custom plugin Publish to npm Share with community","title":"Plugins"},{"location":"features/plugins/#plugin-basics","text":"Create a plugin in src/plugins/ : // src/plugins/my-plugin.ts export default { name : 'my-plugin' , version : '1.0.0' , description : 'My custom plugin' , onBuild : async ( context ) => { console . log ( 'Building...' ); }, onServe : async ( context ) => { console . log ( 'Serving...' ); }, onDeploy : async ( context ) => { console . log ( 'Deploying...' ); } };","title":"Plugin Basics"},{"location":"features/plugins/#register-plugin","text":"In jen.config.ts : import myPlugin from '@src/plugins/my-plugin' ; const config : FrameworkConfig = { plugins : [ myPlugin , '@jen/plugin-analytics' , // npm package './src/plugins/custom.ts' ] };","title":"Register Plugin"},{"location":"features/plugins/#plugin-hooks","text":"","title":"Plugin Hooks"},{"location":"features/plugins/#onbuild","text":"Runs during build (SSG): export default { name : 'build-plugin' , onBuild : async ( context ) => { const { routes , config } = context ; // Process routes console . log ( `Building ${ routes . length } routes` ); // Generate additional files await generateSitemap ( routes ); } };","title":"onBuild"},{"location":"features/plugins/#onserve","text":"Runs when dev server starts: export default { name : 'serve-plugin' , onServe : async ( context ) => { const { server , config } = context ; // Add custom routes server . use ( '/custom' , ( req , res ) => { res . end ( 'Custom route' ); }); console . log ( 'Dev server ready' ); } };","title":"onServe"},{"location":"features/plugins/#ondeploy","text":"Runs during deployment: export default { name : 'deploy-plugin' , onDeploy : async ( context ) => { const { distDir , config } = context ; // Upload to CDN await uploadToS3 ( distDir ); console . log ( 'Deployment complete' ); } };","title":"onDeploy"},{"location":"features/plugins/#example-plugins","text":"","title":"Example Plugins"},{"location":"features/plugins/#sitemap-generator","text":"// src/plugins/sitemap.ts export default { name : 'sitemap-generator' , onBuild : async ( context ) => { const { routes } = context ; const sitemap = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' ; + '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\\n' + routes . map ( route => `<url><loc> ${ route . path } </loc></url>` ). join ( '\\n' ) + '</urlset>' ; await fs . writeFile ( 'dist/sitemap.xml' , sitemap ); } };","title":"Sitemap Generator"},{"location":"features/plugins/#analytics-plugin","text":"// src/plugins/analytics.ts export default { name : 'analytics' , onBuild : async ( context ) => { const { distDir } = context ; // Add analytics script to all HTML files const files = glob . sync ( ` ${ distDir } /**/*.html` ); for ( const file of files ) { let content = fs . readFileSync ( file , 'utf-8' ); content = content . replace ( '</head>' , '<script src=\"/analytics.js\"></script>\\n</head>' ); fs . writeFileSync ( file , content ); } } };","title":"Analytics Plugin"},{"location":"features/plugins/#image-optimization-plugin","text":"// src/plugins/image-optimizer.ts export default { name : 'image-optimizer' , onBuild : async ( context ) => { const { distDir } = context ; const images = glob . sync ( ` ${ distDir } /**/*.{jpg,png}` ); for ( const image of images ) { // Compress image await sharp ( image ) . resize ( 1920 , 1080 , { fit : 'inside' }) . toFile ( image ); } } };","title":"Image Optimization Plugin"},{"location":"features/plugins/#plugin-context","text":"Plugins receive context with: interface PluginContext { config : FrameworkConfig ; // Framework config routes : Route []; // Discovered routes distDir : string ; // Build output directory siteDir : string ; // Source directory server? : ExpressApp ; // Dev server (in onServe) isDev : boolean ; // Development mode? timestamp : Date ; // Build/serve timestamp }","title":"Plugin Context"},{"location":"features/plugins/#creating-reusable-plugins","text":"Export as npm package: { \"name\" : \"@myorg/jen-plugin-custom\" , \"version\" : \"1.0.0\" , \"main\" : \"dist/index.js\" , \"types\" : \"dist/index.d.ts\" } // src/index.ts export default { name : '@myorg/custom' , onBuild : async ( context ) => { // Plugin logic } }; Install and use: npm install @myorg/jen-plugin-custom import customPlugin from '@myorg/jen-plugin-custom' ; const config = { plugins : [ customPlugin ] };","title":"Creating Reusable Plugins"},{"location":"features/plugins/#plugin-configuration","text":"Pass options to plugins: // src/plugins/configurable.ts export default function createPlugin ( options = {}) { return { name : 'configurable' , onBuild : async ( context ) => { if ( options . enabled ) { // Run plugin } } }; } Use with configuration: import createPlugin from '@src/plugins/configurable' ; const config = { plugins : [ createPlugin ({ enabled : true , setting : 'value' }) ] };","title":"Plugin Configuration"},{"location":"features/plugins/#error-handling","text":"Plugins should handle errors gracefully: export default { name : 'safe-plugin' , onBuild : async ( context ) => { try { const result = await riskyOperation (); console . log ( 'Success:' , result ); } catch ( err ) { console . error ( 'Plugin error:' , err ); // Don't throw \u2014 let build continue } } };","title":"Error Handling"},{"location":"features/plugins/#best-practices","text":"Use descriptive plugin names Include version information Handle errors gracefully Document plugin options Use namespaces for organization Test plugins thoroughly Publish reusable plugins to npm Provide TypeScript types","title":"Best Practices"},{"location":"features/plugins/#testing-plugins","text":"// plugin.test.ts import plugin from '@src/plugins/my-plugin' ; test ( 'plugin runs on build' , async () => { const context = { routes : [{ path : '/' }], config : {}, distDir : './dist' }; await plugin . onBuild ( context ); // Assert plugin behavior });","title":"Testing Plugins"},{"location":"features/plugins/#next-steps","text":"Create a custom plugin Publish to npm Share with community","title":"Next Steps"},{"location":"features/rendering/","text":"Jen.js supports both Static Site Generation (SSG) and Server-Side Rendering (SSR). Choose the best approach for each route. Static Site Generation (SSG) Pre-build all pages into static HTML at build time. When to Use SSG Blog posts and articles Documentation sites Marketing pages Any content that doesn't change per request How SSG Works npm run build Jen.js scans all routes in site/ Runs each loader function Renders each page to HTML Outputs static files to dist/ Deploy dist/ to CDN Example site/(about).tsx export async function loader () { // This runs at build time return { title : 'About Us' , content : 'Our company...' }; } export default function About ({ data } : any ) { return ( < html > < head >< title > { data . title } < /title></head> < body > { data . content } < /body> < /html> ); } Dynamic Routes with SSG For routes with dynamic parameters, precompute paths: site/posts/($slug).tsx import type { LoaderContext } from '@src/core/routes' ; // Tell SSG what paths to generate export async function staticPaths () { const posts = await getAllPosts (); return posts . map ( post => ({ slug : post.slug })); } export async function loader ( ctx : LoaderContext ) { const post = await getPost ( ctx . params . slug ); return { post }; } export default function Post ({ data } : any ) { return < article > { data . post . content } < /article>; } Generates: - /posts/hello-world - /posts/getting-started - etc. SSG Configuration In jen.config.ts : const config : FrameworkConfig = { rendering : { defaultMode : 'ssg' , defaultRevalidateSeconds : 3600 // Revalidate hourly } }; Or per-route: // site/(about).tsx export const mode = 'ssg' ; export const revalidate = 86400 ; // 1 day export default function About () { // ... } Incremental Static Regeneration Rebuild specific pages without full rebuild: npm run build -- --incremental site/ ( about ) .tsx Server-Side Rendering (SSR) Render pages on each request. Dynamic, always fresh content. When to Use SSR User-specific content Real-time data Personalized pages Any content that changes frequently How SSR Works npm run dev # Start dev server npm run start # Start production server Request comes in Jen.js loads the route file Runs loader function Renders component to HTML Sends to browser Example site/dashboard/($userId).tsx import type { LoaderContext } from '@src/core/routes' ; export async function loader ( ctx : LoaderContext ) { // This runs on EVERY request const user = await getUser ( ctx . params . userId ); const stats = await getUserStats ( user . id ); return { user , stats }; } export default function Dashboard ({ data } : any ) { return ( < html > < head >< title > { data . user . name } ' s Dashboard < /title></head> < body > < h1 > Welcome , { data . user . name } < /h1> < p > Posts : { data . stats . postCount } < /p> < /body> < /html> ); } SSR Configuration In jen.config.ts : const config : FrameworkConfig = { rendering : { defaultMode : 'ssr' }, server : { port : 3000 , timeout : 30000 // 30 second timeout } }; Or per-route: // site/(home).tsx export const mode = 'ssr' ; export default function Home () { // ... } Hybrid Approach Use both SSG and SSR in the same application. Configuration const config : FrameworkConfig = { rendering : { defaultMode : 'ssg' // Most routes are static } }; Then override for specific routes: // site/(about).tsx - Static export const mode = 'ssg' ; export default function About () { /* */ } // site/dashboard/($id).tsx - Dynamic export const mode = 'ssr' ; export default function Dashboard () { /* */ } Smart Build During build, Jen.js: 1. Generates all SSG routes 2. Skips SSR routes (handled at runtime) 3. Outputs mixed static + dynamic setup Perfect for: - Static home page - Dynamic user dashboards - Static blog posts - Dynamic user profiles Client-Side Hydration Pages can be interactive with Preact: import { useState } from 'preact/hooks' ; export default function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < html > < head >< title > Counter < /title></head> < body > < h1 > Count : { count } < /h1> < button onClick = {() => setCount ( count + 1 )} > Increment < /button> < /body> < /html> ); } Hydration in SSG For SSG pages with interactivity: Page generates as static HTML JavaScript bundle included in build Browser loads HTML + JavaScript Preact hydrates (takes over) Now fully interactive Hydration in SSR For SSR pages: Server renders HTML with current state JavaScript bundle sent to browser Preact hydrates with same state Interactivity works immediately Cache Control HTTP Caching Control browser/CDN caching: export async function loader ( ctx : LoaderContext ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); // ... } Revalidation For SSG with Incremental Static Regeneration: export const revalidate = 300 ; // Revalidate every 5 minutes export async function loader () { return { data : await fetchData () }; } Pages are served from cache, revalidated in background. Performance Tips For SSG Pre-render all static pages Serve from CDN Cache indefinitely (use versioning for updates) Rebuild on content changes For SSR Implement page-level caching Use middleware for compression Monitor response times Cache database queries For Hybrid Use SSG for high-traffic static content Use SSR for low-traffic dynamic content Cache API responses Pre-render above-the-fold content Monitoring Build Time Check build performance: npm run build -- --verbose Runtime Monitor SSR performance: export async function loader ( ctx : LoaderContext ) { const start = Date . now (); const data = await fetchData (); console . log ( `Loader took ${ Date . now () - start } ms` ); return { data }; } Best Practices Default to SSG \u2014 Most content should be static Use SSR only when needed \u2014 For truly dynamic content Cache aggressively \u2014 Both browser and server-side Precompute static paths \u2014 Use staticPaths() for dynamic routes Monitor performance \u2014 Measure build and request times Use revalidation \u2014 Keep content fresh without full rebuilds","title":"SSG & SSR"},{"location":"features/rendering/#static-site-generation-ssg","text":"Pre-build all pages into static HTML at build time.","title":"Static Site Generation (SSG)"},{"location":"features/rendering/#when-to-use-ssg","text":"Blog posts and articles Documentation sites Marketing pages Any content that doesn't change per request","title":"When to Use SSG"},{"location":"features/rendering/#how-ssg-works","text":"npm run build Jen.js scans all routes in site/ Runs each loader function Renders each page to HTML Outputs static files to dist/ Deploy dist/ to CDN","title":"How SSG Works"},{"location":"features/rendering/#example","text":"site/(about).tsx export async function loader () { // This runs at build time return { title : 'About Us' , content : 'Our company...' }; } export default function About ({ data } : any ) { return ( < html > < head >< title > { data . title } < /title></head> < body > { data . content } < /body> < /html> ); }","title":"Example"},{"location":"features/rendering/#dynamic-routes-with-ssg","text":"For routes with dynamic parameters, precompute paths: site/posts/($slug).tsx import type { LoaderContext } from '@src/core/routes' ; // Tell SSG what paths to generate export async function staticPaths () { const posts = await getAllPosts (); return posts . map ( post => ({ slug : post.slug })); } export async function loader ( ctx : LoaderContext ) { const post = await getPost ( ctx . params . slug ); return { post }; } export default function Post ({ data } : any ) { return < article > { data . post . content } < /article>; } Generates: - /posts/hello-world - /posts/getting-started - etc.","title":"Dynamic Routes with SSG"},{"location":"features/rendering/#ssg-configuration","text":"In jen.config.ts : const config : FrameworkConfig = { rendering : { defaultMode : 'ssg' , defaultRevalidateSeconds : 3600 // Revalidate hourly } }; Or per-route: // site/(about).tsx export const mode = 'ssg' ; export const revalidate = 86400 ; // 1 day export default function About () { // ... }","title":"SSG Configuration"},{"location":"features/rendering/#incremental-static-regeneration","text":"Rebuild specific pages without full rebuild: npm run build -- --incremental site/ ( about ) .tsx","title":"Incremental Static Regeneration"},{"location":"features/rendering/#server-side-rendering-ssr","text":"Render pages on each request. Dynamic, always fresh content.","title":"Server-Side Rendering (SSR)"},{"location":"features/rendering/#when-to-use-ssr","text":"User-specific content Real-time data Personalized pages Any content that changes frequently","title":"When to Use SSR"},{"location":"features/rendering/#how-ssr-works","text":"npm run dev # Start dev server npm run start # Start production server Request comes in Jen.js loads the route file Runs loader function Renders component to HTML Sends to browser","title":"How SSR Works"},{"location":"features/rendering/#example_1","text":"site/dashboard/($userId).tsx import type { LoaderContext } from '@src/core/routes' ; export async function loader ( ctx : LoaderContext ) { // This runs on EVERY request const user = await getUser ( ctx . params . userId ); const stats = await getUserStats ( user . id ); return { user , stats }; } export default function Dashboard ({ data } : any ) { return ( < html > < head >< title > { data . user . name } ' s Dashboard < /title></head> < body > < h1 > Welcome , { data . user . name } < /h1> < p > Posts : { data . stats . postCount } < /p> < /body> < /html> ); }","title":"Example"},{"location":"features/rendering/#ssr-configuration","text":"In jen.config.ts : const config : FrameworkConfig = { rendering : { defaultMode : 'ssr' }, server : { port : 3000 , timeout : 30000 // 30 second timeout } }; Or per-route: // site/(home).tsx export const mode = 'ssr' ; export default function Home () { // ... }","title":"SSR Configuration"},{"location":"features/rendering/#hybrid-approach","text":"Use both SSG and SSR in the same application.","title":"Hybrid Approach"},{"location":"features/rendering/#configuration","text":"const config : FrameworkConfig = { rendering : { defaultMode : 'ssg' // Most routes are static } }; Then override for specific routes: // site/(about).tsx - Static export const mode = 'ssg' ; export default function About () { /* */ } // site/dashboard/($id).tsx - Dynamic export const mode = 'ssr' ; export default function Dashboard () { /* */ }","title":"Configuration"},{"location":"features/rendering/#smart-build","text":"During build, Jen.js: 1. Generates all SSG routes 2. Skips SSR routes (handled at runtime) 3. Outputs mixed static + dynamic setup Perfect for: - Static home page - Dynamic user dashboards - Static blog posts - Dynamic user profiles","title":"Smart Build"},{"location":"features/rendering/#client-side-hydration","text":"Pages can be interactive with Preact: import { useState } from 'preact/hooks' ; export default function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < html > < head >< title > Counter < /title></head> < body > < h1 > Count : { count } < /h1> < button onClick = {() => setCount ( count + 1 )} > Increment < /button> < /body> < /html> ); }","title":"Client-Side Hydration"},{"location":"features/rendering/#hydration-in-ssg","text":"For SSG pages with interactivity: Page generates as static HTML JavaScript bundle included in build Browser loads HTML + JavaScript Preact hydrates (takes over) Now fully interactive","title":"Hydration in SSG"},{"location":"features/rendering/#hydration-in-ssr","text":"For SSR pages: Server renders HTML with current state JavaScript bundle sent to browser Preact hydrates with same state Interactivity works immediately","title":"Hydration in SSR"},{"location":"features/rendering/#cache-control","text":"","title":"Cache Control"},{"location":"features/rendering/#http-caching","text":"Control browser/CDN caching: export async function loader ( ctx : LoaderContext ) { ctx . response . setHeader ( 'Cache-Control' , 'public, max-age=3600' ); // ... }","title":"HTTP Caching"},{"location":"features/rendering/#revalidation","text":"For SSG with Incremental Static Regeneration: export const revalidate = 300 ; // Revalidate every 5 minutes export async function loader () { return { data : await fetchData () }; } Pages are served from cache, revalidated in background.","title":"Revalidation"},{"location":"features/rendering/#performance-tips","text":"","title":"Performance Tips"},{"location":"features/rendering/#for-ssg","text":"Pre-render all static pages Serve from CDN Cache indefinitely (use versioning for updates) Rebuild on content changes","title":"For SSG"},{"location":"features/rendering/#for-ssr","text":"Implement page-level caching Use middleware for compression Monitor response times Cache database queries","title":"For SSR"},{"location":"features/rendering/#for-hybrid","text":"Use SSG for high-traffic static content Use SSR for low-traffic dynamic content Cache API responses Pre-render above-the-fold content","title":"For Hybrid"},{"location":"features/rendering/#monitoring","text":"","title":"Monitoring"},{"location":"features/rendering/#build-time","text":"Check build performance: npm run build -- --verbose","title":"Build Time"},{"location":"features/rendering/#runtime","text":"Monitor SSR performance: export async function loader ( ctx : LoaderContext ) { const start = Date . now (); const data = await fetchData (); console . log ( `Loader took ${ Date . now () - start } ms` ); return { data }; }","title":"Runtime"},{"location":"features/rendering/#best-practices","text":"Default to SSG \u2014 Most content should be static Use SSR only when needed \u2014 For truly dynamic content Cache aggressively \u2014 Both browser and server-side Precompute static paths \u2014 Use staticPaths() for dynamic routes Monitor performance \u2014 Measure build and request times Use revalidation \u2014 Keep content fresh without full rebuilds","title":"Best Practices"},{"location":"getting-started/installation/","text":"System Requirements Node.js 16.x or higher npm, yarn, or pnpm TypeScript 5.x or higher (included in project) Quick Start Option 1: Using create-jen-js (Recommended) npm create jen-js@latest my-app cd my-app npm install npm run dev Visit http://localhost:3000 to see your app. Option 2: Manual Setup Create a new directory and initialize: mkdir my-app cd my-app npm init -y Install dependencies: npm install \\ preact \\ preact-render-to-string \\ esbuild \\ typescript \\ @types/node Create folder structure: mkdir -p src site dist Create tsconfig.json : { \"compilerOptions\" : { \"target\" : \"ES2022\" , \"module\" : \"ES2020\" , \"lib\" : [ \"ES2022\" ], \"jsx\" : \"react-jsx\" , \"jsxImportSource\" : \"preact\" , \"strict\" : true , \"moduleResolution\" : \"bundler\" , \"resolveJsonModule\" : true , \"allowImportingTsExtensions\" : true , \"baseUrl\" : \".\" , \"paths\" : { \"@src/*\" : [ \"src/*\" ] } }, \"include\" : [ \"src/**/*.ts\" , \"src/**/*.tsx\" , \"site/**/*.tsx\" ] } Create package.json scripts: { \"scripts\" : { \"dev\" : \"node server.ts dev\" , \"start\" : \"node server.ts start\" , \"build\" : \"node build.js\" , \"typecheck\" : \"tsc --noEmit\" } } Option 3: From GitHub Clone the repository: git clone https://github.com/your-repo/jen-js.git cd jen-js npm install npm run dev Verify Installation Run type checking: npm run typecheck Should complete without errors. First Page Create site/(home).tsx : export default function Home () { return ( < html > < head > < title > Hello Jen . js < /title> < /head> < body > < h1 > Welcome to Jen . js < /h1> < p > This is your first page !< /p> < /body> < /html> ); } Start dev server: npm run dev Visit http://localhost:3000 Configuration File Create jen.config.ts in your project root: import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , rendering : { defaultMode : 'ssr' , defaultRevalidateSeconds : 60 }, routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true } }; export default config ; Environment Variables Create .env file (optional): DATABASE_URL=sqlite://./data.db REDIS_URL=redis://localhost:6379 JWT_SECRET=your-secret-key NODE_ENV=development Access in code: const dbUrl = process . env . DATABASE_URL ; Next Steps Read the Quick Start guide Learn about routing Create your first interactive page Set up a database","title":"Installation"},{"location":"getting-started/installation/#system-requirements","text":"Node.js 16.x or higher npm, yarn, or pnpm TypeScript 5.x or higher (included in project)","title":"System Requirements"},{"location":"getting-started/installation/#quick-start","text":"","title":"Quick Start"},{"location":"getting-started/installation/#option-1-using-create-jen-js-recommended","text":"npm create jen-js@latest my-app cd my-app npm install npm run dev Visit http://localhost:3000 to see your app.","title":"Option 1: Using create-jen-js (Recommended)"},{"location":"getting-started/installation/#option-2-manual-setup","text":"Create a new directory and initialize: mkdir my-app cd my-app npm init -y Install dependencies: npm install \\ preact \\ preact-render-to-string \\ esbuild \\ typescript \\ @types/node Create folder structure: mkdir -p src site dist Create tsconfig.json : { \"compilerOptions\" : { \"target\" : \"ES2022\" , \"module\" : \"ES2020\" , \"lib\" : [ \"ES2022\" ], \"jsx\" : \"react-jsx\" , \"jsxImportSource\" : \"preact\" , \"strict\" : true , \"moduleResolution\" : \"bundler\" , \"resolveJsonModule\" : true , \"allowImportingTsExtensions\" : true , \"baseUrl\" : \".\" , \"paths\" : { \"@src/*\" : [ \"src/*\" ] } }, \"include\" : [ \"src/**/*.ts\" , \"src/**/*.tsx\" , \"site/**/*.tsx\" ] } Create package.json scripts: { \"scripts\" : { \"dev\" : \"node server.ts dev\" , \"start\" : \"node server.ts start\" , \"build\" : \"node build.js\" , \"typecheck\" : \"tsc --noEmit\" } }","title":"Option 2: Manual Setup"},{"location":"getting-started/installation/#option-3-from-github","text":"Clone the repository: git clone https://github.com/your-repo/jen-js.git cd jen-js npm install npm run dev","title":"Option 3: From GitHub"},{"location":"getting-started/installation/#verify-installation","text":"Run type checking: npm run typecheck Should complete without errors.","title":"Verify Installation"},{"location":"getting-started/installation/#first-page","text":"Create site/(home).tsx : export default function Home () { return ( < html > < head > < title > Hello Jen . js < /title> < /head> < body > < h1 > Welcome to Jen . js < /h1> < p > This is your first page !< /p> < /body> < /html> ); } Start dev server: npm run dev Visit http://localhost:3000","title":"First Page"},{"location":"getting-started/installation/#configuration-file","text":"Create jen.config.ts in your project root: import type { FrameworkConfig } from '@src/core/config' ; const config : FrameworkConfig = { siteDir : 'site' , distDir : 'dist' , rendering : { defaultMode : 'ssr' , defaultRevalidateSeconds : 60 }, routes : { fileExtensions : [ '.tsx' , '.jsx' , '.ts' , '.js' ], routeFilePattern : /^\\((.+)\\)\\.(t|j)sx?$/ , enableIndexFallback : true } }; export default config ;","title":"Configuration File"},{"location":"getting-started/installation/#environment-variables","text":"Create .env file (optional): DATABASE_URL=sqlite://./data.db REDIS_URL=redis://localhost:6379 JWT_SECRET=your-secret-key NODE_ENV=development Access in code: const dbUrl = process . env . DATABASE_URL ;","title":"Environment Variables"},{"location":"getting-started/installation/#next-steps","text":"Read the Quick Start guide Learn about routing Create your first interactive page Set up a database","title":"Next Steps"},{"location":"getting-started/intro/","text":"What is Jen.js? Jen.js is a TypeScript-first, full-stack web framework that combines: TypeScript \u2014 Type-safe development with strict mode Preact \u2014 Lightweight component framework (3KB vs React's 40KB+) File-based routing \u2014 Zero-config route discovery Dual rendering \u2014 SSG for static sites, SSR for dynamic content Production-optimized \u2014 Minimal bundle sizes and fast performance Think of it as Next.js for TypeScript teams who want lightweight, performant applications . Core Philosophies TypeScript First All code is written in TypeScript with strict type checking. You get: - Type safety across your entire application - Better IDE support and auto-completion - Compile-time error detection Progressive Enhancement Build static sites when possible (SSG) Switch to dynamic rendering (SSR) when needed No JavaScript by default (unless you need interactivity) Simplicity by Default File-based routing \u2014 no configuration needed Preact for minimal overhead Native modules for performance-critical paths Extensibility Plugin system for custom functionality Middleware system for request handling Multiple database drivers Framework Highlights Zero-Config Routing Your file structure automatically becomes your routes: site/ \u251c\u2500\u2500 (home).tsx \u2192 / \u251c\u2500\u2500 (about).tsx \u2192 /about \u251c\u2500\u2500 posts/ \u2502 \u2514\u2500\u2500 ($id).tsx \u2192 /posts/:id \u2514\u2500\u2500 api/ \u2514\u2500\u2500 (users).ts \u2192 /api/users Preact Components Write interactive UIs with Preact (70% API compatible with React): export default function HomePage () { const [ count , setCount ] = useState ( 0 ); return ( < div > < h1 > Welcome < /h1> < button onClick = {() => setCount ( count + 1 )} > Clicks : { count } < /button> < /div> ); } Dual Rendering Modes Static Site Generation (SSG) npm run build # Generates pre-rendered HTML Benefits: - Fast, cacheable, no server needed - Perfect for blogs, docs, marketing sites - Lower hosting costs (CDN only) Server-Side Rendering (SSR) npm run dev # Dynamic rendering per request npm run start # Production server Benefits: - Real-time content, personalization - SEO-friendly dynamic rendering - Instant updates without rebuilding Multiple Database Support Pick your database: // SQLite (embedded, zero config) const db = new DB ({ type : \"sqlite\" }); // PostgreSQL / MySQL (production) const db = new DB ({ type : \"postgres\" , ... }); // MongoDB const db = new DB ({ type : \"mongodb\" , ... }); // jDB (Jen's embedded database) const db = new DB ({ type : \"jdb\" , ... }); Plugin System Extend Jen.js with custom plugins: // src/plugin/plugins/my-plugin.ts export default { name : \"my-plugin\" , onBuild : async () => { console . log ( \"Building...\" ); }, onServe : async () => { console . log ( \"Server running...\" ); } }; Project Structure jen.js/ \u251c\u2500\u2500 src/ # Framework source code \u2502 \u251c\u2500\u2500 build/ # Static site generation logic \u2502 \u251c\u2500\u2500 server/ # HTTP server and SSR \u2502 \u251c\u2500\u2500 core/ # Core config, routing, types \u2502 \u251c\u2500\u2500 runtime/ # Preact SSR and hydration \u2502 \u251c\u2500\u2500 api/ # REST API utilities \u2502 \u251c\u2500\u2500 auth/ # Authentication (JWT) \u2502 \u251c\u2500\u2500 cache/ # Caching layer \u2502 \u251c\u2500\u2500 db/ # Database abstraction \u2502 \u251c\u2500\u2500 middleware/ # Express-style middleware \u2502 \u251c\u2500\u2500 plugin/ # Plugin system \u2502 \u251c\u2500\u2500 native/ # Native module stubs \u2502 \u251c\u2500\u2500 cli/ # CLI tooling \u2502 \u2514\u2500\u2500 shared/ # Shared utilities \u251c\u2500\u2500 site/ # Your application \u2502 \u251c\u2500\u2500 (home).tsx \u2502 \u251c\u2500\u2500 (about).tsx \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2514\u2500\u2500 api/ \u251c\u2500\u2500 dist/ # Build output (generated) \u251c\u2500\u2500 jen.config.ts # Configuration \u251c\u2500\u2500 build.ts # Build entry point \u2514\u2500\u2500 server.ts # Server entry point When to Use Jen.js Jen.js is ideal for: Blogs and documentation sites Marketing websites with dynamic content Hybrid applications (static + dynamic) API-first applications Teams familiar with React/TypeScript Projects requiring type safety Applications needing multiple database drivers When to Consider Alternatives If you need a pure frontend framework \u2192 Use React/Vue/Svelte If you need a backend framework \u2192 Use Express/Fastify If you need GraphQL-only \u2192 Consider Apollo Server If you need complex routing \u2192 Consider other frameworks","title":"Introduction"},{"location":"getting-started/intro/#what-is-jenjs","text":"Jen.js is a TypeScript-first, full-stack web framework that combines: TypeScript \u2014 Type-safe development with strict mode Preact \u2014 Lightweight component framework (3KB vs React's 40KB+) File-based routing \u2014 Zero-config route discovery Dual rendering \u2014 SSG for static sites, SSR for dynamic content Production-optimized \u2014 Minimal bundle sizes and fast performance Think of it as Next.js for TypeScript teams who want lightweight, performant applications .","title":"What is Jen.js?"},{"location":"getting-started/intro/#core-philosophies","text":"","title":"Core Philosophies"},{"location":"getting-started/intro/#typescript-first","text":"All code is written in TypeScript with strict type checking. You get: - Type safety across your entire application - Better IDE support and auto-completion - Compile-time error detection","title":"TypeScript First"},{"location":"getting-started/intro/#progressive-enhancement","text":"Build static sites when possible (SSG) Switch to dynamic rendering (SSR) when needed No JavaScript by default (unless you need interactivity)","title":"Progressive Enhancement"},{"location":"getting-started/intro/#simplicity-by-default","text":"File-based routing \u2014 no configuration needed Preact for minimal overhead Native modules for performance-critical paths","title":"Simplicity by Default"},{"location":"getting-started/intro/#extensibility","text":"Plugin system for custom functionality Middleware system for request handling Multiple database drivers","title":"Extensibility"},{"location":"getting-started/intro/#framework-highlights","text":"","title":"Framework Highlights"},{"location":"getting-started/intro/#zero-config-routing","text":"Your file structure automatically becomes your routes: site/ \u251c\u2500\u2500 (home).tsx \u2192 / \u251c\u2500\u2500 (about).tsx \u2192 /about \u251c\u2500\u2500 posts/ \u2502 \u2514\u2500\u2500 ($id).tsx \u2192 /posts/:id \u2514\u2500\u2500 api/ \u2514\u2500\u2500 (users).ts \u2192 /api/users","title":"Zero-Config Routing"},{"location":"getting-started/intro/#preact-components","text":"Write interactive UIs with Preact (70% API compatible with React): export default function HomePage () { const [ count , setCount ] = useState ( 0 ); return ( < div > < h1 > Welcome < /h1> < button onClick = {() => setCount ( count + 1 )} > Clicks : { count } < /button> < /div> ); }","title":"Preact Components"},{"location":"getting-started/intro/#dual-rendering-modes","text":"Static Site Generation (SSG) npm run build # Generates pre-rendered HTML Benefits: - Fast, cacheable, no server needed - Perfect for blogs, docs, marketing sites - Lower hosting costs (CDN only) Server-Side Rendering (SSR) npm run dev # Dynamic rendering per request npm run start # Production server Benefits: - Real-time content, personalization - SEO-friendly dynamic rendering - Instant updates without rebuilding","title":"Dual Rendering Modes"},{"location":"getting-started/intro/#multiple-database-support","text":"Pick your database: // SQLite (embedded, zero config) const db = new DB ({ type : \"sqlite\" }); // PostgreSQL / MySQL (production) const db = new DB ({ type : \"postgres\" , ... }); // MongoDB const db = new DB ({ type : \"mongodb\" , ... }); // jDB (Jen's embedded database) const db = new DB ({ type : \"jdb\" , ... });","title":"Multiple Database Support"},{"location":"getting-started/intro/#plugin-system","text":"Extend Jen.js with custom plugins: // src/plugin/plugins/my-plugin.ts export default { name : \"my-plugin\" , onBuild : async () => { console . log ( \"Building...\" ); }, onServe : async () => { console . log ( \"Server running...\" ); } };","title":"Plugin System"},{"location":"getting-started/intro/#project-structure","text":"jen.js/ \u251c\u2500\u2500 src/ # Framework source code \u2502 \u251c\u2500\u2500 build/ # Static site generation logic \u2502 \u251c\u2500\u2500 server/ # HTTP server and SSR \u2502 \u251c\u2500\u2500 core/ # Core config, routing, types \u2502 \u251c\u2500\u2500 runtime/ # Preact SSR and hydration \u2502 \u251c\u2500\u2500 api/ # REST API utilities \u2502 \u251c\u2500\u2500 auth/ # Authentication (JWT) \u2502 \u251c\u2500\u2500 cache/ # Caching layer \u2502 \u251c\u2500\u2500 db/ # Database abstraction \u2502 \u251c\u2500\u2500 middleware/ # Express-style middleware \u2502 \u251c\u2500\u2500 plugin/ # Plugin system \u2502 \u251c\u2500\u2500 native/ # Native module stubs \u2502 \u251c\u2500\u2500 cli/ # CLI tooling \u2502 \u2514\u2500\u2500 shared/ # Shared utilities \u251c\u2500\u2500 site/ # Your application \u2502 \u251c\u2500\u2500 (home).tsx \u2502 \u251c\u2500\u2500 (about).tsx \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2514\u2500\u2500 api/ \u251c\u2500\u2500 dist/ # Build output (generated) \u251c\u2500\u2500 jen.config.ts # Configuration \u251c\u2500\u2500 build.ts # Build entry point \u2514\u2500\u2500 server.ts # Server entry point","title":"Project Structure"},{"location":"getting-started/intro/#when-to-use-jenjs","text":"Jen.js is ideal for: Blogs and documentation sites Marketing websites with dynamic content Hybrid applications (static + dynamic) API-first applications Teams familiar with React/TypeScript Projects requiring type safety Applications needing multiple database drivers","title":"When to Use Jen.js"},{"location":"getting-started/intro/#when-to-consider-alternatives","text":"If you need a pure frontend framework \u2192 Use React/Vue/Svelte If you need a backend framework \u2192 Use Express/Fastify If you need GraphQL-only \u2192 Consider Apollo Server If you need complex routing \u2192 Consider other frameworks","title":"When to Consider Alternatives"},{"location":"getting-started/quick-start/","text":"Create Your First App npm create jen-js@latest my-app cd my-app npm install npm run dev Open http://localhost:3000 in your browser. Creating Pages Pages are files in the site/ directory. Each file becomes a route. Simple Page Create site/(hello).tsx : export default function HelloPage () { return ( < html > < head > < title > Hello < /title> < /head> < body > < h1 > Hello World < /h1> < p > This page is at / hello < /p> < /body> < /html> ); } Visit http://localhost:3000/hello Page with Data Pages can load data using a loader function: import type { LoaderContext } from '@src/core/routes' ; interface PageData { title : string ; message : string ; } export async function loader ( ctx : LoaderContext ) : Promise < PageData > { return { title : 'About Us' , message : 'Welcome to our site!' }; } export default function About ({ data } : { data : PageData }) { return ( < html > < head > < title > { data . title } < /title> < /head> < body > < h1 > { data . title } < /h1> < p > { data . message } < /p> < /body> < /html> ); } Dynamic Routes Create site/posts/($id).tsx : import type { LoaderContext } from '@src/core/routes' ; export async function loader ( ctx : LoaderContext ) { const postId = ctx . params . id ; // Fetch post data return { id : postId , title : `Post ${ postId } ` , content : 'Post content here...' }; } export default function Post ({ data } : any ) { return ( < html > < head > < title > { data . title } < /title> < /head> < body > < h1 > { data . title } < /h1> < p > { data . content } < /p> < /body> < /html> ); } Access with URLs like /posts/1 , /posts/hello , etc. Interactive Pages Use Preact hooks for interactivity: import { useState } from 'preact/hooks' ; export default function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < html > < head > < title > Counter < /title> < /head> < body > < h1 > Counter App < /h1> < p > Count : { count } < /p> < button onClick = {() => setCount ( count + 1 )} > Increment < /button> < /body> < /html> ); } API Routes Create site/api/(users).ts : import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [ { id : 1 , name : 'Alice' }, { id : 2 , name : 'Bob' } ] })); } } Access with GET /api/users to get JSON response. Building for Production Static Site Generation npm run build Creates static HTML in dist/ . Deploy to any CDN: # Serve locally npx serve dist # Deploy to Netlify, Vercel, etc. Server-Side Rendering Keep dev server running: npm run start Or build and serve: npm run build npm run start Project Structure my-app/ \u251c\u2500\u2500 site/ \u2502 \u251c\u2500\u2500 (home).tsx # Homepage at / \u2502 \u251c\u2500\u2500 (about).tsx # About at /about \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u2514\u2500\u2500 ($id).tsx # Dynamic at /posts/:id \u2502 \u2514\u2500\u2500 api/ \u2502 \u2514\u2500\u2500 (users).ts # API at /api/users \u251c\u2500\u2500 src/ # Optional: custom code \u251c\u2500\u2500 dist/ # Generated output \u251c\u2500\u2500 jen.config.ts # Framework config \u251c\u2500\u2500 tsconfig.json # TypeScript config \u251c\u2500\u2500 package.json \u2514\u2500\u2500 README.md Common Tasks Add a New Page Create file in site/ with naming pattern: (name).tsx Export default component Optionally export loader function for data Handle Forms export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const data = JSON . parse ( body ); // Process form data res . writeHead ( 200 ); res . end ( JSON . stringify ({ success : true })); }); } } Add Styles Create a CSS file or use inline styles: const styles = ` body { font-family: sans-serif; } h1 { color: blue; } ` ; export default function StyledPage () { return ( < html > < head > < style > { styles } < /style> < /head> < body > < h1 > Styled Page < /h1> < /body> < /html> ); } Use Components Create reusable components in src/ : // src/components/header.tsx export function Header () { return < header >< h1 > My Site < /h1></header>; } Use in pages: import { Header } from '@src/components/header' ; export default function Home () { return ( < html > < head >< title > Home < /title></head> < body > < Header /> < main > Home page < /main> < /body> < /html> ); } Next Steps Learn about routing in detail Set up a database Add authentication Create API routes Deploy your app","title":"Quick Start"},{"location":"getting-started/quick-start/#create-your-first-app","text":"npm create jen-js@latest my-app cd my-app npm install npm run dev Open http://localhost:3000 in your browser.","title":"Create Your First App"},{"location":"getting-started/quick-start/#creating-pages","text":"Pages are files in the site/ directory. Each file becomes a route.","title":"Creating Pages"},{"location":"getting-started/quick-start/#simple-page","text":"Create site/(hello).tsx : export default function HelloPage () { return ( < html > < head > < title > Hello < /title> < /head> < body > < h1 > Hello World < /h1> < p > This page is at / hello < /p> < /body> < /html> ); } Visit http://localhost:3000/hello","title":"Simple Page"},{"location":"getting-started/quick-start/#page-with-data","text":"Pages can load data using a loader function: import type { LoaderContext } from '@src/core/routes' ; interface PageData { title : string ; message : string ; } export async function loader ( ctx : LoaderContext ) : Promise < PageData > { return { title : 'About Us' , message : 'Welcome to our site!' }; } export default function About ({ data } : { data : PageData }) { return ( < html > < head > < title > { data . title } < /title> < /head> < body > < h1 > { data . title } < /h1> < p > { data . message } < /p> < /body> < /html> ); }","title":"Page with Data"},{"location":"getting-started/quick-start/#dynamic-routes","text":"Create site/posts/($id).tsx : import type { LoaderContext } from '@src/core/routes' ; export async function loader ( ctx : LoaderContext ) { const postId = ctx . params . id ; // Fetch post data return { id : postId , title : `Post ${ postId } ` , content : 'Post content here...' }; } export default function Post ({ data } : any ) { return ( < html > < head > < title > { data . title } < /title> < /head> < body > < h1 > { data . title } < /h1> < p > { data . content } < /p> < /body> < /html> ); } Access with URLs like /posts/1 , /posts/hello , etc.","title":"Dynamic Routes"},{"location":"getting-started/quick-start/#interactive-pages","text":"Use Preact hooks for interactivity: import { useState } from 'preact/hooks' ; export default function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < html > < head > < title > Counter < /title> < /head> < body > < h1 > Counter App < /h1> < p > Count : { count } < /p> < button onClick = {() => setCount ( count + 1 )} > Increment < /button> < /body> < /html> ); }","title":"Interactive Pages"},{"location":"getting-started/quick-start/#api-routes","text":"Create site/api/(users).ts : import type { IncomingMessage , ServerResponse } from 'node:http' ; export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'GET' ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ users : [ { id : 1 , name : 'Alice' }, { id : 2 , name : 'Bob' } ] })); } } Access with GET /api/users to get JSON response.","title":"API Routes"},{"location":"getting-started/quick-start/#building-for-production","text":"","title":"Building for Production"},{"location":"getting-started/quick-start/#static-site-generation","text":"npm run build Creates static HTML in dist/ . Deploy to any CDN: # Serve locally npx serve dist # Deploy to Netlify, Vercel, etc.","title":"Static Site Generation"},{"location":"getting-started/quick-start/#server-side-rendering","text":"Keep dev server running: npm run start Or build and serve: npm run build npm run start","title":"Server-Side Rendering"},{"location":"getting-started/quick-start/#project-structure","text":"my-app/ \u251c\u2500\u2500 site/ \u2502 \u251c\u2500\u2500 (home).tsx # Homepage at / \u2502 \u251c\u2500\u2500 (about).tsx # About at /about \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u2514\u2500\u2500 ($id).tsx # Dynamic at /posts/:id \u2502 \u2514\u2500\u2500 api/ \u2502 \u2514\u2500\u2500 (users).ts # API at /api/users \u251c\u2500\u2500 src/ # Optional: custom code \u251c\u2500\u2500 dist/ # Generated output \u251c\u2500\u2500 jen.config.ts # Framework config \u251c\u2500\u2500 tsconfig.json # TypeScript config \u251c\u2500\u2500 package.json \u2514\u2500\u2500 README.md","title":"Project Structure"},{"location":"getting-started/quick-start/#common-tasks","text":"","title":"Common Tasks"},{"location":"getting-started/quick-start/#add-a-new-page","text":"Create file in site/ with naming pattern: (name).tsx Export default component Optionally export loader function for data","title":"Add a New Page"},{"location":"getting-started/quick-start/#handle-forms","text":"export async function handle ( req : IncomingMessage , res : ServerResponse ) { if ( req . method === 'POST' ) { let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const data = JSON . parse ( body ); // Process form data res . writeHead ( 200 ); res . end ( JSON . stringify ({ success : true })); }); } }","title":"Handle Forms"},{"location":"getting-started/quick-start/#add-styles","text":"Create a CSS file or use inline styles: const styles = ` body { font-family: sans-serif; } h1 { color: blue; } ` ; export default function StyledPage () { return ( < html > < head > < style > { styles } < /style> < /head> < body > < h1 > Styled Page < /h1> < /body> < /html> ); }","title":"Add Styles"},{"location":"getting-started/quick-start/#use-components","text":"Create reusable components in src/ : // src/components/header.tsx export function Header () { return < header >< h1 > My Site < /h1></header>; } Use in pages: import { Header } from '@src/components/header' ; export default function Home () { return ( < html > < head >< title > Home < /title></head> < body > < Header /> < main > Home page < /main> < /body> < /html> ); }","title":"Use Components"},{"location":"getting-started/quick-start/#next-steps","text":"Learn about routing in detail Set up a database Add authentication Create API routes Deploy your app","title":"Next Steps"},{"location":"guides/blog/","text":"Complete guide to building a production-ready blog. Project Setup npm create jen-js@latest my-blog cd my-blog npm install File Structure my-blog/ \u251c\u2500\u2500 site/ \u2502 \u251c\u2500\u2500 (home).tsx # Blog homepage \u2502 \u251c\u2500\u2500 (about).tsx # About page \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u251c\u2500\u2500 (index).tsx # Posts list \u2502 \u2502 \u2514\u2500\u2500 ($slug).tsx # Individual post \u2502 \u2514\u2500\u2500 api/ \u2502 \u2514\u2500\u2500 (posts).ts # Posts API \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 header.tsx \u2502 \u2502 \u251c\u2500\u2500 footer.tsx \u2502 \u2502 \u2514\u2500\u2500 post-card.tsx \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 posts.ts \u2502 \u2514\u2500\u2500 styles/ \u2502 \u2514\u2500\u2500 globals.css \u251c\u2500\u2500 posts/ # Markdown posts \u2502 \u251c\u2500\u2500 hello-world.md \u2502 \u2514\u2500\u2500 getting-started.md \u2514\u2500\u2500 public/ \u2514\u2500\u2500 images/ Post Data Structure Posts stored in database or markdown files: interface Post { id : string ; slug : string ; title : string ; excerpt : string ; content : string ; author : string ; category : string ; tags : string []; published : boolean ; createdAt : Date ; updatedAt : Date ; featured : boolean ; } Database Setup Create posts table: // src/lib/posts.ts import { DB } from '@src/db' ; let db : DB ; export async function initDB () { db = new DB ({ type : 'sqlite' , config : { filename : './blog.db' } }); await db . connect (); // Create posts table await db . exec ( ` CREATE TABLE IF NOT EXISTS posts ( id TEXT PRIMARY KEY, slug TEXT UNIQUE NOT NULL, title TEXT NOT NULL, excerpt TEXT, content TEXT NOT NULL, author TEXT, category TEXT, tags TEXT, published BOOLEAN DEFAULT FALSE, featured BOOLEAN DEFAULT FALSE, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ); CREATE INDEX IF NOT EXISTS idx_slug ON posts(slug); CREATE INDEX IF NOT EXISTS idx_published ON posts(published); ` ); } export async function getPost ( slug : string ) { const post = await db . findOne ( 'posts' , { slug , published : true }); if ( post && post . tags ) { post . tags = JSON . parse ( post . tags ); } return post ; } export async function getPosts ( options = {}) { const posts = await db . find ( 'posts' , { published : true }, { sort : { created_at : - 1 }, ... options } ); return posts . map ( p => ({ ... p , tags : p.tags ? JSON . parse ( p . tags ) : [] })); } export async function getFeaturedPosts ( limit = 5 ) { return db . find ( 'posts' , { published : true , featured : true }, { limit , sort : { created_at : - 1 } } ); } export async function getPostsByCategory ( category : string ) { return db . find ( 'posts' , { published : true , category }, { sort : { created_at : - 1 } } ); } export async function getPostsByTag ( tag : string ) { return db . find ( 'posts' , { published : true }, { sort : { created_at : - 1 } } ). then ( posts => posts . filter ( p => JSON . parse ( p . tags || '[]' ). includes ( tag ) ) ); } Homepage site/(home).tsx import { Header } from '@src/components/header' ; import { Footer } from '@src/components/footer' ; import { getFeaturedPosts } from '@src/lib/posts' ; export async function loader () { const featured = await getFeaturedPosts ( 3 ); return { featured }; } export default function Home ({ data } : any ) { return ( < html > < head > < title > My Blog < /title> < meta name = \"description\" content = \"Welcome to my blog\" /> < /head> < body > < Header /> < main > < section class = \"hero\" > < h1 > Welcome to My Blog < /h1> < p > Thoughts on web development and technology < /p> < /section> < section class = \"featured\" > < h2 > Featured Posts < /h2> < div class = \"posts-grid\" > { data . featured . map ( post => ( < article key = { post . id } > < h3 >< a href = { `/posts/ ${ post . slug } ` } > { post . title } < /a></h3> < p > { post . excerpt } < /p> < a href = { `/posts/ ${ post . slug } ` } > Read More < /a> < /article> ))} < /div> < /section> < /main> < Footer /> < /body> < /html> ); } Posts List site/posts/(index).tsx import { getPosts } from '@src/lib/posts' ; export async function loader ( ctx ) { const page = parseInt ( ctx . query . get ( 'page' ) || '1' ); const limit = 10 ; const offset = ( page - 1 ) * limit ; const posts = await getPosts ({ limit , offset }); const total = await db . count ( 'posts' , { published : true }); return { posts , page , total , pages : Math.ceil ( total / limit ) }; } export default function PostsList ({ data } : any ) { return ( < html > < head > < title > All Posts < /title> < /head> < body > < h1 > Blog Posts < /h1> < div class = \"posts-list\" > { data . posts . map ( post => ( < article key = { post . id } class = \"post-item\" > < h2 >< a href = { `/posts/ ${ post . slug } ` } > { post . title } < /a></h2> < p class = \"meta\" > By { post . author } | { new Date ( post . created_at ). toLocaleDateString ()} < /p> < p > { post . excerpt } < /p> < div class = \"tags\" > { JSON . parse ( post . tags || '[]' ). map ( tag => ( < a href = { `/posts?tag= ${ tag } ` } class = \"tag\" > { tag } < /a> ))} < /div> < /article> ))} < /div> { /* Pagination */ } < div class = \"pagination\" > { data . page > 1 && ( < a href = { `/posts?page= ${ data . page - 1 } ` } > Previous < /a> )} < span > Page { data . page } of { data . pages } < /span> { data . page < data . pages && ( < a href = { `/posts?page= ${ data . page + 1 } ` } > Next < /a> )} < /div> < /body> < /html> ); } Post Detail site/posts/($slug).tsx import { getPost } from '@src/lib/posts' ; import type { LoaderContext } from '@src/core/routes' ; export async function staticPaths () { const posts = await getPosts ({ limit : 1000 }); return posts . map ( p => ({ slug : p.slug })); } export async function loader ( ctx : LoaderContext ) { const post = await getPost ( ctx . params . slug ); if ( ! post ) { ctx . response . writeHead ( 404 ); ctx . response . end ( 'Not found' ); return {}; } return { post }; } export function Head ({ data } : any ) { return ( <> < title > { data . post . title } < /title> < meta name = \"description\" content = { data . post . excerpt } /> < meta property = \"og:title\" content = { data . post . title } /> < meta property = \"og:description\" content = { data . post . excerpt } /> < /> ); } export default function Post ({ data } : any ) { const post = data . post ; return ( < html > < head > < style > { ` article { max-width: 800px; margin: 0 auto; } .meta { color: #666; font-size: 0.9em; } .tags { margin: 1em 0; } .tag { display: inline-block; background: #eee; padding: 0.25em 0.5em; margin-right: 0.5em; text-decoration: none; } ` } < /style> < /head> < body > < article > < h1 > { post . title } < /h1> < div class = \"meta\" > < p > By { post . author } < /p> < p > { new Date ( post . created_at ). toLocaleDateString ()} < /p> { post . category && < p > Category : { post . category } < /p>} < /div> < div class = \"tags\" > { JSON . parse ( post . tags || '[]' ). map ( tag => ( < a key = { tag } href = { `/posts?tag= ${ tag } ` } class = \"tag\" > { tag } < /a> ))} < /div> < div class = \"content\" > { post . content } < /div> < /article> < /body> < /html> ); } // Enable SSG and cache for 1 day export const mode = 'ssg' ; export const revalidate = 86400 ; Posts API site/api/(posts).ts import { getPosts , getPost } from '@src/lib/posts' ; export async function handle ( req , res ) { const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); if ( req . method === 'GET' ) { const slug = url . searchParams . get ( 'slug' ); if ( slug ) { const post = await getPost ( slug ); if ( post ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( post )); } else { res . writeHead ( 404 ); res . end ( JSON . stringify ({ error : 'Not found' })); } } else { const page = parseInt ( url . searchParams . get ( 'page' ) || '1' ); const limit = 10 ; const offset = ( page - 1 ) * limit ; const posts = await getPosts ({ limit , offset }); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( posts )); } } } Styling src/styles/globals.css * { margin : 0 ; padding : 0 ; box-sizing : border-box ; } body { font-family : - apple-system , BlinkMacSystemFont , 'Segoe UI' , sans-serif ; line-height : 1.6 ; color : #333 ; background : #fff ; } main { max-width : 1000 px ; margin : 0 auto ; padding : 2 em 1 em ; } article { margin-bottom : 2 em ; padding-bottom : 2 em ; border-bottom : 1 px solid #eee ; } a { color : #0066cc ; text-decoration : none ; } a : hover { text-decoration : underline ; } . hero { text-align : center ; padding : 4 em 1 em ; background : linear-gradient ( 135 deg , #667eea 0 % , #764ba2 100 % ); color : white ; } . hero h1 { font-size : 3 em ; margin-bottom : 0.5 em ; } . posts-grid { display : grid ; grid-template-columns : repeat ( auto -fill , minmax ( 300 px , 1 fr )); gap : 2 em ; margin : 2 em 0 ; } . meta { color : #666 ; font-size : 0.9 em ; margin : 0.5 em 0 ; } . tags { display : flex ; flex-wrap : wrap ; gap : 0.5 em ; margin : 1 em 0 ; } . tag { background : #eee ; padding : 0.25 em 0.75 em ; border-radius : 1 em ; font-size : 0.9 em ; } . pagination { display : flex ; justify-content : center ; gap : 1 em ; margin : 2 em 0 ; } Production Checklist Set up database with proper indexing Add SEO metadata (title, description, og tags) Implement sitemap generation Add RSS feed Enable caching for posts Set up search functionality Add comments system (optional) Configure analytics Add social sharing buttons Set up email newsletter Optimize images Mobile responsive design Test performance Deploy to production Next Steps Add more features (comments, search, etc.) Customize styling Add deployment configuration Set up analytics Create admin interface for posts","title":"Building a Blog"},{"location":"guides/blog/#project-setup","text":"npm create jen-js@latest my-blog cd my-blog npm install","title":"Project Setup"},{"location":"guides/blog/#file-structure","text":"my-blog/ \u251c\u2500\u2500 site/ \u2502 \u251c\u2500\u2500 (home).tsx # Blog homepage \u2502 \u251c\u2500\u2500 (about).tsx # About page \u2502 \u251c\u2500\u2500 posts/ \u2502 \u2502 \u251c\u2500\u2500 (index).tsx # Posts list \u2502 \u2502 \u2514\u2500\u2500 ($slug).tsx # Individual post \u2502 \u2514\u2500\u2500 api/ \u2502 \u2514\u2500\u2500 (posts).ts # Posts API \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u251c\u2500\u2500 header.tsx \u2502 \u2502 \u251c\u2500\u2500 footer.tsx \u2502 \u2502 \u2514\u2500\u2500 post-card.tsx \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2514\u2500\u2500 posts.ts \u2502 \u2514\u2500\u2500 styles/ \u2502 \u2514\u2500\u2500 globals.css \u251c\u2500\u2500 posts/ # Markdown posts \u2502 \u251c\u2500\u2500 hello-world.md \u2502 \u2514\u2500\u2500 getting-started.md \u2514\u2500\u2500 public/ \u2514\u2500\u2500 images/","title":"File Structure"},{"location":"guides/blog/#post-data-structure","text":"Posts stored in database or markdown files: interface Post { id : string ; slug : string ; title : string ; excerpt : string ; content : string ; author : string ; category : string ; tags : string []; published : boolean ; createdAt : Date ; updatedAt : Date ; featured : boolean ; }","title":"Post Data Structure"},{"location":"guides/blog/#database-setup","text":"Create posts table: // src/lib/posts.ts import { DB } from '@src/db' ; let db : DB ; export async function initDB () { db = new DB ({ type : 'sqlite' , config : { filename : './blog.db' } }); await db . connect (); // Create posts table await db . exec ( ` CREATE TABLE IF NOT EXISTS posts ( id TEXT PRIMARY KEY, slug TEXT UNIQUE NOT NULL, title TEXT NOT NULL, excerpt TEXT, content TEXT NOT NULL, author TEXT, category TEXT, tags TEXT, published BOOLEAN DEFAULT FALSE, featured BOOLEAN DEFAULT FALSE, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ); CREATE INDEX IF NOT EXISTS idx_slug ON posts(slug); CREATE INDEX IF NOT EXISTS idx_published ON posts(published); ` ); } export async function getPost ( slug : string ) { const post = await db . findOne ( 'posts' , { slug , published : true }); if ( post && post . tags ) { post . tags = JSON . parse ( post . tags ); } return post ; } export async function getPosts ( options = {}) { const posts = await db . find ( 'posts' , { published : true }, { sort : { created_at : - 1 }, ... options } ); return posts . map ( p => ({ ... p , tags : p.tags ? JSON . parse ( p . tags ) : [] })); } export async function getFeaturedPosts ( limit = 5 ) { return db . find ( 'posts' , { published : true , featured : true }, { limit , sort : { created_at : - 1 } } ); } export async function getPostsByCategory ( category : string ) { return db . find ( 'posts' , { published : true , category }, { sort : { created_at : - 1 } } ); } export async function getPostsByTag ( tag : string ) { return db . find ( 'posts' , { published : true }, { sort : { created_at : - 1 } } ). then ( posts => posts . filter ( p => JSON . parse ( p . tags || '[]' ). includes ( tag ) ) ); }","title":"Database Setup"},{"location":"guides/blog/#homepage","text":"site/(home).tsx import { Header } from '@src/components/header' ; import { Footer } from '@src/components/footer' ; import { getFeaturedPosts } from '@src/lib/posts' ; export async function loader () { const featured = await getFeaturedPosts ( 3 ); return { featured }; } export default function Home ({ data } : any ) { return ( < html > < head > < title > My Blog < /title> < meta name = \"description\" content = \"Welcome to my blog\" /> < /head> < body > < Header /> < main > < section class = \"hero\" > < h1 > Welcome to My Blog < /h1> < p > Thoughts on web development and technology < /p> < /section> < section class = \"featured\" > < h2 > Featured Posts < /h2> < div class = \"posts-grid\" > { data . featured . map ( post => ( < article key = { post . id } > < h3 >< a href = { `/posts/ ${ post . slug } ` } > { post . title } < /a></h3> < p > { post . excerpt } < /p> < a href = { `/posts/ ${ post . slug } ` } > Read More < /a> < /article> ))} < /div> < /section> < /main> < Footer /> < /body> < /html> ); }","title":"Homepage"},{"location":"guides/blog/#posts-list","text":"site/posts/(index).tsx import { getPosts } from '@src/lib/posts' ; export async function loader ( ctx ) { const page = parseInt ( ctx . query . get ( 'page' ) || '1' ); const limit = 10 ; const offset = ( page - 1 ) * limit ; const posts = await getPosts ({ limit , offset }); const total = await db . count ( 'posts' , { published : true }); return { posts , page , total , pages : Math.ceil ( total / limit ) }; } export default function PostsList ({ data } : any ) { return ( < html > < head > < title > All Posts < /title> < /head> < body > < h1 > Blog Posts < /h1> < div class = \"posts-list\" > { data . posts . map ( post => ( < article key = { post . id } class = \"post-item\" > < h2 >< a href = { `/posts/ ${ post . slug } ` } > { post . title } < /a></h2> < p class = \"meta\" > By { post . author } | { new Date ( post . created_at ). toLocaleDateString ()} < /p> < p > { post . excerpt } < /p> < div class = \"tags\" > { JSON . parse ( post . tags || '[]' ). map ( tag => ( < a href = { `/posts?tag= ${ tag } ` } class = \"tag\" > { tag } < /a> ))} < /div> < /article> ))} < /div> { /* Pagination */ } < div class = \"pagination\" > { data . page > 1 && ( < a href = { `/posts?page= ${ data . page - 1 } ` } > Previous < /a> )} < span > Page { data . page } of { data . pages } < /span> { data . page < data . pages && ( < a href = { `/posts?page= ${ data . page + 1 } ` } > Next < /a> )} < /div> < /body> < /html> ); }","title":"Posts List"},{"location":"guides/blog/#post-detail","text":"site/posts/($slug).tsx import { getPost } from '@src/lib/posts' ; import type { LoaderContext } from '@src/core/routes' ; export async function staticPaths () { const posts = await getPosts ({ limit : 1000 }); return posts . map ( p => ({ slug : p.slug })); } export async function loader ( ctx : LoaderContext ) { const post = await getPost ( ctx . params . slug ); if ( ! post ) { ctx . response . writeHead ( 404 ); ctx . response . end ( 'Not found' ); return {}; } return { post }; } export function Head ({ data } : any ) { return ( <> < title > { data . post . title } < /title> < meta name = \"description\" content = { data . post . excerpt } /> < meta property = \"og:title\" content = { data . post . title } /> < meta property = \"og:description\" content = { data . post . excerpt } /> < /> ); } export default function Post ({ data } : any ) { const post = data . post ; return ( < html > < head > < style > { ` article { max-width: 800px; margin: 0 auto; } .meta { color: #666; font-size: 0.9em; } .tags { margin: 1em 0; } .tag { display: inline-block; background: #eee; padding: 0.25em 0.5em; margin-right: 0.5em; text-decoration: none; } ` } < /style> < /head> < body > < article > < h1 > { post . title } < /h1> < div class = \"meta\" > < p > By { post . author } < /p> < p > { new Date ( post . created_at ). toLocaleDateString ()} < /p> { post . category && < p > Category : { post . category } < /p>} < /div> < div class = \"tags\" > { JSON . parse ( post . tags || '[]' ). map ( tag => ( < a key = { tag } href = { `/posts?tag= ${ tag } ` } class = \"tag\" > { tag } < /a> ))} < /div> < div class = \"content\" > { post . content } < /div> < /article> < /body> < /html> ); } // Enable SSG and cache for 1 day export const mode = 'ssg' ; export const revalidate = 86400 ;","title":"Post Detail"},{"location":"guides/blog/#posts-api","text":"site/api/(posts).ts import { getPosts , getPost } from '@src/lib/posts' ; export async function handle ( req , res ) { const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); if ( req . method === 'GET' ) { const slug = url . searchParams . get ( 'slug' ); if ( slug ) { const post = await getPost ( slug ); if ( post ) { res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( post )); } else { res . writeHead ( 404 ); res . end ( JSON . stringify ({ error : 'Not found' })); } } else { const page = parseInt ( url . searchParams . get ( 'page' ) || '1' ); const limit = 10 ; const offset = ( page - 1 ) * limit ; const posts = await getPosts ({ limit , offset }); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ( posts )); } } }","title":"Posts API"},{"location":"guides/blog/#styling","text":"src/styles/globals.css * { margin : 0 ; padding : 0 ; box-sizing : border-box ; } body { font-family : - apple-system , BlinkMacSystemFont , 'Segoe UI' , sans-serif ; line-height : 1.6 ; color : #333 ; background : #fff ; } main { max-width : 1000 px ; margin : 0 auto ; padding : 2 em 1 em ; } article { margin-bottom : 2 em ; padding-bottom : 2 em ; border-bottom : 1 px solid #eee ; } a { color : #0066cc ; text-decoration : none ; } a : hover { text-decoration : underline ; } . hero { text-align : center ; padding : 4 em 1 em ; background : linear-gradient ( 135 deg , #667eea 0 % , #764ba2 100 % ); color : white ; } . hero h1 { font-size : 3 em ; margin-bottom : 0.5 em ; } . posts-grid { display : grid ; grid-template-columns : repeat ( auto -fill , minmax ( 300 px , 1 fr )); gap : 2 em ; margin : 2 em 0 ; } . meta { color : #666 ; font-size : 0.9 em ; margin : 0.5 em 0 ; } . tags { display : flex ; flex-wrap : wrap ; gap : 0.5 em ; margin : 1 em 0 ; } . tag { background : #eee ; padding : 0.25 em 0.75 em ; border-radius : 1 em ; font-size : 0.9 em ; } . pagination { display : flex ; justify-content : center ; gap : 1 em ; margin : 2 em 0 ; }","title":"Styling"},{"location":"guides/blog/#production-checklist","text":"Set up database with proper indexing Add SEO metadata (title, description, og tags) Implement sitemap generation Add RSS feed Enable caching for posts Set up search functionality Add comments system (optional) Configure analytics Add social sharing buttons Set up email newsletter Optimize images Mobile responsive design Test performance Deploy to production","title":"Production Checklist"},{"location":"guides/blog/#next-steps","text":"Add more features (comments, search, etc.) Customize styling Add deployment configuration Set up analytics Create admin interface for posts","title":"Next Steps"},{"location":"guides/file-uploads/","text":"Guide to implementing file uploads in Jen.js. Simple File Upload Create upload endpoint: // site/api/(upload).ts import { writeFileSync } from 'node:fs' ; import { randomBytes } from 'node:crypto' ; import { extname } from 'node:path' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let chunks = []; let size = 0 ; req . on ( 'data' , chunk => { chunks . push ( chunk ); size += chunk . length ; // Limit to 10MB if ( size > 10 * 1024 * 1024 ) { req . pause (); res . writeHead ( 413 ); res . end ( 'File too large' ); } }); req . on ( 'end' , () => { const buffer = Buffer . concat ( chunks ); const filename = `upload- ${ randomBytes ( 8 ). toString ( 'hex' ) } ` ; const filepath = `./public/uploads/ ${ filename } ` ; writeFileSync ( filepath , buffer ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , filename , url : `/uploads/ ${ filename } ` })); }); } } Multipart Form Data Parse multipart uploads: // src/lib/upload.ts export function parseMultipart ( req ) { return new Promise (( resolve , reject ) => { const boundary = req . headers [ 'content-type' ] ? . split ( 'boundary=' )[ 1 ]; let data = '' ; let file = null ; req . on ( 'data' , chunk => { data += chunk . toString (); }); req . on ( 'end' , () => { // Parse boundary-separated data const parts = data . split ( `-- ${ boundary } ` ); const formData = {}; let fileData = null ; let filename = '' ; for ( const part of parts ) { if ( part . includes ( 'Content-Disposition: form-data' )) { const nameMatch = /name=\"([^\"]+)\"/ . exec ( part ); const filenameMatch = /filename=\"([^\"]+)\"/ . exec ( part ); if ( nameMatch && filenameMatch ) { filename = filenameMatch [ 1 ]; const contentStart = part . indexOf ( '\\r\\n\\r\\n' ) + 4 ; fileData = part . substring ( contentStart ). trim (); } else if ( nameMatch ) { const name = nameMatch [ 1 ]; const contentStart = part . indexOf ( '\\r\\n\\r\\n' ) + 4 ; const value = part . substring ( contentStart ). trim (); formData [ name ] = value ; } } } resolve ({ formData , file : { filename , data : fileData } }); }); req . on ( 'error' , reject ); }); } Use it: import { parseMultipart } from '@src/lib/upload' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { try { const { formData , file } = await parseMultipart ( req ); // Save file writeFileSync ( `./public/uploads/ ${ file . filename } ` , file . data ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , filename : file.filename , fields : formData })); } catch ( err ) { res . writeHead ( 400 ); res . end ( 'Upload failed' ); } } } Upload Form HTML form for uploading: // site/(upload).tsx export default function UploadPage () { return ( < html > < head > < title > Upload File < /title> < /head> < body > < h1 > Upload File < /h1> < form id = \"upload-form\" action = \"/api/upload\" method = \"POST\" > < input type = \"file\" name = \"file\" required /> < button type = \"submit\" > Upload < /button> < /form> < div id = \"result\" >< /div> < script > { ` const form = document.getElementById('upload-form'); const result = document.getElementById('result'); form.addEventListener('submit', async (e) => { e.preventDefault(); const formData = new FormData(form); try { const res = await fetch('/api/upload', { method: 'POST', body: formData }); const data = await res.json(); if (data.success) { result.innerHTML = \\` <p>Upload successful!</p> <img src=\"\\${data.url}\" alt=\"Uploaded\" /> \\`; } } catch (err) { result.innerHTML = '<p>Upload failed</p>'; } }); ` } < /script> < /body> < /html> ); } Image Processing Process uploaded images: // Install: npm install sharp import sharp from 'sharp' ; import { writeFileSync } from 'node:fs' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let chunks = []; req . on ( 'data' , chunk => chunks . push ( chunk )); req . on ( 'end' , async () => { try { const buffer = Buffer . concat ( chunks ); // Resize image const resized = await sharp ( buffer ) . resize ( 800 , 600 , { fit : 'inside' }) . toBuffer (); const filename = `image- ${ Date . now () } .jpg` ; writeFileSync ( `./public/uploads/ ${ filename } ` , resized ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , url : `/uploads/ ${ filename } ` })); } catch ( err ) { res . writeHead ( 400 ); res . end ( 'Image processing failed' ); } }); } } Validation Validate uploaded files: function validateFile ( filename , size , mimeType ) { // Check extension const allowed = [ '.jpg' , '.jpeg' , '.png' , '.gif' , '.pdf' ]; const ext = filename . slice ( filename . lastIndexOf ( '.' )). toLowerCase (); if ( ! allowed . includes ( ext )) { return { valid : false , error : 'Invalid file type' }; } // Check size (10MB limit) if ( size > 10 * 1024 * 1024 ) { return { valid : false , error : 'File too large' }; } // Check MIME type const allowedMimes = [ 'image/jpeg' , 'image/png' , 'image/gif' , 'application/pdf' ]; if ( ! allowedMimes . includes ( mimeType )) { return { valid : false , error : 'Invalid MIME type' }; } return { valid : true }; } export async function handle ( req , res ) { if ( req . method === 'POST' ) { const filename = req . headers [ 'x-filename' ]; const size = parseInt ( req . headers [ 'content-length' ]); const mimeType = req . headers [ 'content-type' ]; const validation = validateFile ( filename , size , mimeType ); if ( ! validation . valid ) { res . writeHead ( 400 ); res . end ( JSON . stringify ({ error : validation.error })); return ; } // Process upload... } } Database Storage Store file metadata in database: // site/api/(upload).ts import { getDB } from '@src/lib/db' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let chunks = []; req . on ( 'data' , chunk => chunks . push ( chunk )); req . on ( 'end' , async () => { try { const buffer = Buffer . concat ( chunks ); const filename = ` ${ Date . now () } .jpg` ; const filepath = `./public/uploads/ ${ filename } ` ; writeFileSync ( filepath , buffer ); const db = getDB (); const file = await db . insert ( 'uploads' , { filename , path : filepath , size : buffer.length , mime_type : 'image/jpeg' , uploaded_at : new Date () }); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , id : file.id , url : `/uploads/ ${ filename } ` })); } catch ( err ) { res . writeHead ( 500 ); res . end ( 'Upload failed' ); } }); } } Progress Tracking Track upload progress on client: export default function UploadPage () { return ( < html > < head >< title > Upload with Progress < /title></head> < body > < input type = \"file\" id = \"file\" /> < progress id = \"progress\" max = \"100\" >< /progress> < div id = \"status\" >< /div> < script > { ` const fileInput = document.getElementById('file'); const progress = document.getElementById('progress'); const status = document.getElementById('status'); fileInput.addEventListener('change', (e) => { const file = e.target.files[0]; const xhr = new XMLHttpRequest(); xhr.upload.addEventListener('progress', (e) => { if (e.lengthComputable) { const percent = (e.loaded / e.total) * 100; progress.value = percent; status.textContent = \\`\\${Math.round(percent)}%\\`; } }); xhr.addEventListener('load', () => { status.textContent = 'Upload complete!'; }); xhr.open('POST', '/api/upload'); xhr.send(file); }); ` } < /script> < /body> < /html> ); } Cleanup Remove old uploads: // src/lib/cleanup.ts import { unlink } from 'node:fs/promises' ; import { getDB } from './db' ; export async function cleanupOldUploads ( days = 30 ) { const db = getDB (); const cutoff = new Date ( Date . now () - days * 24 * 60 * 60 * 1000 ); const old = await db . find ( 'uploads' , { uploaded_at : { $lt : cutoff } }); for ( const file of old ) { try { await unlink ( file . path ); await db . delete ( 'uploads' , { id : file.id }); } catch ( err ) { console . error ( `Failed to clean up ${ file . filename } :` , err ); } } } Best Practices Validate file types and size Store metadata in database Use random filenames to prevent collisions Implement rate limiting Scan for malware Use CDN for serving files Implement cleanup for old files Track upload progress Handle errors gracefully Use HTTPS for uploads","title":"File Uploads"},{"location":"guides/file-uploads/#simple-file-upload","text":"Create upload endpoint: // site/api/(upload).ts import { writeFileSync } from 'node:fs' ; import { randomBytes } from 'node:crypto' ; import { extname } from 'node:path' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let chunks = []; let size = 0 ; req . on ( 'data' , chunk => { chunks . push ( chunk ); size += chunk . length ; // Limit to 10MB if ( size > 10 * 1024 * 1024 ) { req . pause (); res . writeHead ( 413 ); res . end ( 'File too large' ); } }); req . on ( 'end' , () => { const buffer = Buffer . concat ( chunks ); const filename = `upload- ${ randomBytes ( 8 ). toString ( 'hex' ) } ` ; const filepath = `./public/uploads/ ${ filename } ` ; writeFileSync ( filepath , buffer ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , filename , url : `/uploads/ ${ filename } ` })); }); } }","title":"Simple File Upload"},{"location":"guides/file-uploads/#multipart-form-data","text":"Parse multipart uploads: // src/lib/upload.ts export function parseMultipart ( req ) { return new Promise (( resolve , reject ) => { const boundary = req . headers [ 'content-type' ] ? . split ( 'boundary=' )[ 1 ]; let data = '' ; let file = null ; req . on ( 'data' , chunk => { data += chunk . toString (); }); req . on ( 'end' , () => { // Parse boundary-separated data const parts = data . split ( `-- ${ boundary } ` ); const formData = {}; let fileData = null ; let filename = '' ; for ( const part of parts ) { if ( part . includes ( 'Content-Disposition: form-data' )) { const nameMatch = /name=\"([^\"]+)\"/ . exec ( part ); const filenameMatch = /filename=\"([^\"]+)\"/ . exec ( part ); if ( nameMatch && filenameMatch ) { filename = filenameMatch [ 1 ]; const contentStart = part . indexOf ( '\\r\\n\\r\\n' ) + 4 ; fileData = part . substring ( contentStart ). trim (); } else if ( nameMatch ) { const name = nameMatch [ 1 ]; const contentStart = part . indexOf ( '\\r\\n\\r\\n' ) + 4 ; const value = part . substring ( contentStart ). trim (); formData [ name ] = value ; } } } resolve ({ formData , file : { filename , data : fileData } }); }); req . on ( 'error' , reject ); }); } Use it: import { parseMultipart } from '@src/lib/upload' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { try { const { formData , file } = await parseMultipart ( req ); // Save file writeFileSync ( `./public/uploads/ ${ file . filename } ` , file . data ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , filename : file.filename , fields : formData })); } catch ( err ) { res . writeHead ( 400 ); res . end ( 'Upload failed' ); } } }","title":"Multipart Form Data"},{"location":"guides/file-uploads/#upload-form","text":"HTML form for uploading: // site/(upload).tsx export default function UploadPage () { return ( < html > < head > < title > Upload File < /title> < /head> < body > < h1 > Upload File < /h1> < form id = \"upload-form\" action = \"/api/upload\" method = \"POST\" > < input type = \"file\" name = \"file\" required /> < button type = \"submit\" > Upload < /button> < /form> < div id = \"result\" >< /div> < script > { ` const form = document.getElementById('upload-form'); const result = document.getElementById('result'); form.addEventListener('submit', async (e) => { e.preventDefault(); const formData = new FormData(form); try { const res = await fetch('/api/upload', { method: 'POST', body: formData }); const data = await res.json(); if (data.success) { result.innerHTML = \\` <p>Upload successful!</p> <img src=\"\\${data.url}\" alt=\"Uploaded\" /> \\`; } } catch (err) { result.innerHTML = '<p>Upload failed</p>'; } }); ` } < /script> < /body> < /html> ); }","title":"Upload Form"},{"location":"guides/file-uploads/#image-processing","text":"Process uploaded images: // Install: npm install sharp import sharp from 'sharp' ; import { writeFileSync } from 'node:fs' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let chunks = []; req . on ( 'data' , chunk => chunks . push ( chunk )); req . on ( 'end' , async () => { try { const buffer = Buffer . concat ( chunks ); // Resize image const resized = await sharp ( buffer ) . resize ( 800 , 600 , { fit : 'inside' }) . toBuffer (); const filename = `image- ${ Date . now () } .jpg` ; writeFileSync ( `./public/uploads/ ${ filename } ` , resized ); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , url : `/uploads/ ${ filename } ` })); } catch ( err ) { res . writeHead ( 400 ); res . end ( 'Image processing failed' ); } }); } }","title":"Image Processing"},{"location":"guides/file-uploads/#validation","text":"Validate uploaded files: function validateFile ( filename , size , mimeType ) { // Check extension const allowed = [ '.jpg' , '.jpeg' , '.png' , '.gif' , '.pdf' ]; const ext = filename . slice ( filename . lastIndexOf ( '.' )). toLowerCase (); if ( ! allowed . includes ( ext )) { return { valid : false , error : 'Invalid file type' }; } // Check size (10MB limit) if ( size > 10 * 1024 * 1024 ) { return { valid : false , error : 'File too large' }; } // Check MIME type const allowedMimes = [ 'image/jpeg' , 'image/png' , 'image/gif' , 'application/pdf' ]; if ( ! allowedMimes . includes ( mimeType )) { return { valid : false , error : 'Invalid MIME type' }; } return { valid : true }; } export async function handle ( req , res ) { if ( req . method === 'POST' ) { const filename = req . headers [ 'x-filename' ]; const size = parseInt ( req . headers [ 'content-length' ]); const mimeType = req . headers [ 'content-type' ]; const validation = validateFile ( filename , size , mimeType ); if ( ! validation . valid ) { res . writeHead ( 400 ); res . end ( JSON . stringify ({ error : validation.error })); return ; } // Process upload... } }","title":"Validation"},{"location":"guides/file-uploads/#database-storage","text":"Store file metadata in database: // site/api/(upload).ts import { getDB } from '@src/lib/db' ; export async function handle ( req , res ) { if ( req . method === 'POST' ) { let chunks = []; req . on ( 'data' , chunk => chunks . push ( chunk )); req . on ( 'end' , async () => { try { const buffer = Buffer . concat ( chunks ); const filename = ` ${ Date . now () } .jpg` ; const filepath = `./public/uploads/ ${ filename } ` ; writeFileSync ( filepath , buffer ); const db = getDB (); const file = await db . insert ( 'uploads' , { filename , path : filepath , size : buffer.length , mime_type : 'image/jpeg' , uploaded_at : new Date () }); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ success : true , id : file.id , url : `/uploads/ ${ filename } ` })); } catch ( err ) { res . writeHead ( 500 ); res . end ( 'Upload failed' ); } }); } }","title":"Database Storage"},{"location":"guides/file-uploads/#progress-tracking","text":"Track upload progress on client: export default function UploadPage () { return ( < html > < head >< title > Upload with Progress < /title></head> < body > < input type = \"file\" id = \"file\" /> < progress id = \"progress\" max = \"100\" >< /progress> < div id = \"status\" >< /div> < script > { ` const fileInput = document.getElementById('file'); const progress = document.getElementById('progress'); const status = document.getElementById('status'); fileInput.addEventListener('change', (e) => { const file = e.target.files[0]; const xhr = new XMLHttpRequest(); xhr.upload.addEventListener('progress', (e) => { if (e.lengthComputable) { const percent = (e.loaded / e.total) * 100; progress.value = percent; status.textContent = \\`\\${Math.round(percent)}%\\`; } }); xhr.addEventListener('load', () => { status.textContent = 'Upload complete!'; }); xhr.open('POST', '/api/upload'); xhr.send(file); }); ` } < /script> < /body> < /html> ); }","title":"Progress Tracking"},{"location":"guides/file-uploads/#cleanup","text":"Remove old uploads: // src/lib/cleanup.ts import { unlink } from 'node:fs/promises' ; import { getDB } from './db' ; export async function cleanupOldUploads ( days = 30 ) { const db = getDB (); const cutoff = new Date ( Date . now () - days * 24 * 60 * 60 * 1000 ); const old = await db . find ( 'uploads' , { uploaded_at : { $lt : cutoff } }); for ( const file of old ) { try { await unlink ( file . path ); await db . delete ( 'uploads' , { id : file.id }); } catch ( err ) { console . error ( `Failed to clean up ${ file . filename } :` , err ); } } }","title":"Cleanup"},{"location":"guides/file-uploads/#best-practices","text":"Validate file types and size Store metadata in database Use random filenames to prevent collisions Implement rate limiting Scan for malware Use CDN for serving files Implement cleanup for old files Track upload progress Handle errors gracefully Use HTTPS for uploads","title":"Best Practices"},{"location":"guides/real-time/","text":"Build real-time applications with Jen.js using Server-Sent Events and polling. Server-Sent Events Stream data to client in real-time: // site/api/(events).ts export async function handle ( req , res ) { if ( req . method === 'GET' ) { // Set SSE headers res . writeHead ( 200 , { 'Content-Type' : 'text/event-stream' , 'Cache-Control' : 'no-cache' , 'Connection' : 'keep-alive' }); // Send initial message res . write ( 'data: Connected\\n\\n' ); // Send updates every second const interval = setInterval (() => { const data = { timestamp : new Date (). toISOString (), value : Math.random () }; res . write ( `data: ${ JSON . stringify ( data ) } \\n\\n` ); }, 1000 ); // Cleanup on disconnect req . on ( 'close' , () => { clearInterval ( interval ); res . end (); }); } } Client-side: export default function RealtimePage () { return ( < html > < head >< title > Real - Time Events < /title></head> < body > < h1 > Live Data < /h1> < div id = \"data\" >< /div> < script > { ` const eventSource = new EventSource('/api/events'); const dataDiv = document.getElementById('data'); eventSource.addEventListener('message', (e) => { try { const data = JSON.parse(e.data); dataDiv.innerHTML = \\` <p>Time: \\${data.timestamp}</p> <p>Value: \\${data.value.toFixed(2)}</p> \\`; } catch { dataDiv.textContent = e.data; } }); eventSource.addEventListener('error', () => { eventSource.close(); }); ` } < /script> < /body> < /html> ); } Polling Regular updates via HTTP: // site/api/(status).ts import { getDB } from '@src/lib/db' ; export async function handle ( req , res ) { if ( req . method === 'GET' ) { const db = getDB (); const status = await db . findOne ( 'system_status' , {}); res . writeHead ( 200 , { 'Content-Type' : 'application/json' , 'Cache-Control' : 'no-cache' }); res . end ( JSON . stringify ( status )); } } Client-side polling: export default function StatusPage () { return ( < html > < head >< title > System Status < /title></head> < body > < h1 > Status < /h1> < div id = \"status\" >< /div> < script > { ` async function updateStatus() { try { const res = await fetch('/api/status'); const data = await res.json(); document.getElementById('status').innerHTML = \\` <p>Uptime: \\${data.uptime}h</p> <p>Users: \\${data.online_users}</p> <p>Memory: \\${data.memory_usage}MB</p> \\`; } catch (err) { console.error('Error fetching status', err); } } // Update every 5 seconds updateStatus(); setInterval(updateStatus, 5000); ` } < /script> < /body> < /html> ); } WebSocket-Like Polling Simulate bidirectional communication: // site/api/(messages).ts const clients = new Map (); let messageId = 0 ; export async function handle ( req , res ) { const clientId = req . headers [ 'x-client-id' ] || Date . now (). toString (); const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); if ( req . method === 'GET' ) { // Fetch messages for client const messages = clients . get ( clientId ) || []; clients . set ( clientId , []); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ messages , clientId })); } else if ( req . method === 'POST' ) { // Receive message from client let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const message = JSON . parse ( body ); // Broadcast to other clients for ( const [ id , msgs ] of clients . entries ()) { if ( id !== clientId ) { msgs . push ({ id : messageId ++ , from : clientId , content : message.content , timestamp : new Date () }); } } res . writeHead ( 200 ); res . end ( 'OK' ); }); } } Client-side chat: export default function ChatPage () { return ( < html > < head >< title > Chat < /title></head> < body > < h1 > Chat < /h1> < div id = \"messages\" >< /div> < input type = \"text\" id = \"input\" placeholder = \"Type message...\" /> < button id = \"send\" > Send < /button> < script > { ` let clientId = null; const messagesDiv = document.getElementById('messages'); const input = document.getElementById('input'); async function fetchMessages() { try { const res = await fetch('/api/messages', { headers: { 'x-client-id': clientId } }); const data = await res.json(); clientId = data.clientId; for (const msg of data.messages) { const div = document.createElement('div'); div.textContent = \\`\\${msg.from}: \\${msg.content}\\`; messagesDiv.appendChild(div); } } catch (err) { console.error('Error fetching messages', err); } } async function sendMessage() { const content = input.value; if (!content) return; try { await fetch('/api/messages', { method: 'POST', headers: { 'content-type': 'application/json', 'x-client-id': clientId }, body: JSON.stringify({ content }) }); input.value = ''; await fetchMessages(); } catch (err) { console.error('Error sending message', err); } } document.getElementById('send').addEventListener('click', sendMessage); // Poll for messages fetchMessages(); setInterval(fetchMessages, 1000); ` } < /script> < /body> < /html> ); } Activity Feed Real-time activity notifications: // site/api/(activity).ts export async function handle ( req , res ) { if ( req . method === 'GET' ) { const db = getDB (); const since = req . headers [ 'if-modified-since' ] || new Date ( 0 ). toISOString (); const activities = await db . find ( 'activities' , { created_at : { $gt : new Date ( since ) } }, { sort : { created_at : - 1 }, limit : 50 }); res . writeHead ( 200 , { 'content-type' : 'application/json' , 'last-modified' : new Date (). toUTCString () }); res . end ( JSON . stringify ( activities )); } else if ( req . method === 'POST' ) { // Log activity let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , async () => { const { type , userId , data } = JSON . parse ( body ); const db = getDB (); await db . insert ( 'activities' , { type , user_id : userId , data : JSON.stringify ( data ), created_at : new Date () }); res . writeHead ( 200 ); res . end ( 'OK' ); }); } } Client-side feed: export default function ActivityFeed () { const [ activities , setActivities ] = useState ([]); useEffect (() => { const fetchActivities = async () => { const lastCheck = localStorage . getItem ( 'lastActivityCheck' ) || new Date ( 0 ). toISOString (); const res = await fetch ( '/api/activity' , { headers : { 'if-modified-since' : lastCheck } }); const data = await res . json (); setActivities ( data ); localStorage . setItem ( 'lastActivityCheck' , new Date (). toISOString ()); }; fetchActivities (); const interval = setInterval ( fetchActivities , 5000 ); return () => clearInterval ( interval ); }, []); return ( < div > < h2 > Activity Feed < /h2> { activities . map ( activity => ( < div key = { activity . id } > < p > { activity . type } < /p> < small > { new Date ( activity . created_at ). toLocaleString ()} < /small> < /div> ))} < /div> ); } Best Practices Use SSE for one-way real-time updates Use polling for low-frequency updates Implement reconnection logic Clean up connections on disconnect Rate limit updates to avoid overload Cache last state for recovery Monitor connection health Use exponential backoff for retries Keep payloads small Test with poor network conditions Performance Tips Debounce frequent updates Batch multiple changes Use delta (only changed data) instead of full state Implement server-side connection pooling Monitor open connections Implement timeouts for stale connections Use compression for large messages","title":"Real-time Features"},{"location":"guides/real-time/#server-sent-events","text":"Stream data to client in real-time: // site/api/(events).ts export async function handle ( req , res ) { if ( req . method === 'GET' ) { // Set SSE headers res . writeHead ( 200 , { 'Content-Type' : 'text/event-stream' , 'Cache-Control' : 'no-cache' , 'Connection' : 'keep-alive' }); // Send initial message res . write ( 'data: Connected\\n\\n' ); // Send updates every second const interval = setInterval (() => { const data = { timestamp : new Date (). toISOString (), value : Math.random () }; res . write ( `data: ${ JSON . stringify ( data ) } \\n\\n` ); }, 1000 ); // Cleanup on disconnect req . on ( 'close' , () => { clearInterval ( interval ); res . end (); }); } } Client-side: export default function RealtimePage () { return ( < html > < head >< title > Real - Time Events < /title></head> < body > < h1 > Live Data < /h1> < div id = \"data\" >< /div> < script > { ` const eventSource = new EventSource('/api/events'); const dataDiv = document.getElementById('data'); eventSource.addEventListener('message', (e) => { try { const data = JSON.parse(e.data); dataDiv.innerHTML = \\` <p>Time: \\${data.timestamp}</p> <p>Value: \\${data.value.toFixed(2)}</p> \\`; } catch { dataDiv.textContent = e.data; } }); eventSource.addEventListener('error', () => { eventSource.close(); }); ` } < /script> < /body> < /html> ); }","title":"Server-Sent Events"},{"location":"guides/real-time/#polling","text":"Regular updates via HTTP: // site/api/(status).ts import { getDB } from '@src/lib/db' ; export async function handle ( req , res ) { if ( req . method === 'GET' ) { const db = getDB (); const status = await db . findOne ( 'system_status' , {}); res . writeHead ( 200 , { 'Content-Type' : 'application/json' , 'Cache-Control' : 'no-cache' }); res . end ( JSON . stringify ( status )); } } Client-side polling: export default function StatusPage () { return ( < html > < head >< title > System Status < /title></head> < body > < h1 > Status < /h1> < div id = \"status\" >< /div> < script > { ` async function updateStatus() { try { const res = await fetch('/api/status'); const data = await res.json(); document.getElementById('status').innerHTML = \\` <p>Uptime: \\${data.uptime}h</p> <p>Users: \\${data.online_users}</p> <p>Memory: \\${data.memory_usage}MB</p> \\`; } catch (err) { console.error('Error fetching status', err); } } // Update every 5 seconds updateStatus(); setInterval(updateStatus, 5000); ` } < /script> < /body> < /html> ); }","title":"Polling"},{"location":"guides/real-time/#websocket-like-polling","text":"Simulate bidirectional communication: // site/api/(messages).ts const clients = new Map (); let messageId = 0 ; export async function handle ( req , res ) { const clientId = req . headers [ 'x-client-id' ] || Date . now (). toString (); const url = new URL ( req . url || '' , `http:// ${ req . headers . host } ` ); if ( req . method === 'GET' ) { // Fetch messages for client const messages = clients . get ( clientId ) || []; clients . set ( clientId , []); res . writeHead ( 200 , { 'content-type' : 'application/json' }); res . end ( JSON . stringify ({ messages , clientId })); } else if ( req . method === 'POST' ) { // Receive message from client let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , () => { const message = JSON . parse ( body ); // Broadcast to other clients for ( const [ id , msgs ] of clients . entries ()) { if ( id !== clientId ) { msgs . push ({ id : messageId ++ , from : clientId , content : message.content , timestamp : new Date () }); } } res . writeHead ( 200 ); res . end ( 'OK' ); }); } } Client-side chat: export default function ChatPage () { return ( < html > < head >< title > Chat < /title></head> < body > < h1 > Chat < /h1> < div id = \"messages\" >< /div> < input type = \"text\" id = \"input\" placeholder = \"Type message...\" /> < button id = \"send\" > Send < /button> < script > { ` let clientId = null; const messagesDiv = document.getElementById('messages'); const input = document.getElementById('input'); async function fetchMessages() { try { const res = await fetch('/api/messages', { headers: { 'x-client-id': clientId } }); const data = await res.json(); clientId = data.clientId; for (const msg of data.messages) { const div = document.createElement('div'); div.textContent = \\`\\${msg.from}: \\${msg.content}\\`; messagesDiv.appendChild(div); } } catch (err) { console.error('Error fetching messages', err); } } async function sendMessage() { const content = input.value; if (!content) return; try { await fetch('/api/messages', { method: 'POST', headers: { 'content-type': 'application/json', 'x-client-id': clientId }, body: JSON.stringify({ content }) }); input.value = ''; await fetchMessages(); } catch (err) { console.error('Error sending message', err); } } document.getElementById('send').addEventListener('click', sendMessage); // Poll for messages fetchMessages(); setInterval(fetchMessages, 1000); ` } < /script> < /body> < /html> ); }","title":"WebSocket-Like Polling"},{"location":"guides/real-time/#activity-feed","text":"Real-time activity notifications: // site/api/(activity).ts export async function handle ( req , res ) { if ( req . method === 'GET' ) { const db = getDB (); const since = req . headers [ 'if-modified-since' ] || new Date ( 0 ). toISOString (); const activities = await db . find ( 'activities' , { created_at : { $gt : new Date ( since ) } }, { sort : { created_at : - 1 }, limit : 50 }); res . writeHead ( 200 , { 'content-type' : 'application/json' , 'last-modified' : new Date (). toUTCString () }); res . end ( JSON . stringify ( activities )); } else if ( req . method === 'POST' ) { // Log activity let body = '' ; req . on ( 'data' , chunk => body += chunk ); req . on ( 'end' , async () => { const { type , userId , data } = JSON . parse ( body ); const db = getDB (); await db . insert ( 'activities' , { type , user_id : userId , data : JSON.stringify ( data ), created_at : new Date () }); res . writeHead ( 200 ); res . end ( 'OK' ); }); } } Client-side feed: export default function ActivityFeed () { const [ activities , setActivities ] = useState ([]); useEffect (() => { const fetchActivities = async () => { const lastCheck = localStorage . getItem ( 'lastActivityCheck' ) || new Date ( 0 ). toISOString (); const res = await fetch ( '/api/activity' , { headers : { 'if-modified-since' : lastCheck } }); const data = await res . json (); setActivities ( data ); localStorage . setItem ( 'lastActivityCheck' , new Date (). toISOString ()); }; fetchActivities (); const interval = setInterval ( fetchActivities , 5000 ); return () => clearInterval ( interval ); }, []); return ( < div > < h2 > Activity Feed < /h2> { activities . map ( activity => ( < div key = { activity . id } > < p > { activity . type } < /p> < small > { new Date ( activity . created_at ). toLocaleString ()} < /small> < /div> ))} < /div> ); }","title":"Activity Feed"},{"location":"guides/real-time/#best-practices","text":"Use SSE for one-way real-time updates Use polling for low-frequency updates Implement reconnection logic Clean up connections on disconnect Rate limit updates to avoid overload Cache last state for recovery Monitor connection health Use exponential backoff for retries Keep payloads small Test with poor network conditions","title":"Best Practices"},{"location":"guides/real-time/#performance-tips","text":"Debounce frequent updates Batch multiple changes Use delta (only changed data) instead of full state Implement server-side connection pooling Monitor open connections Implement timeouts for stale connections Use compression for large messages","title":"Performance Tips"}]}